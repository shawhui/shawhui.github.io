[ { "title": "LeetCode 刷题笔记", "url": "/posts/swift-leetcode/", "categories": "代码人生, LeetCode", "tags": "Swift, LeetCode, 算法, 数据结构", "date": "2021-04-08 12:00:00 +0800", "snippet": "LeetCode 刷题笔记，持续更新ing… 序号 标题 难度 时间复杂度 空间复杂度 题解 1 两数之和 简单 O(n) O(n) Swift 26 删除有序数组中的重复项 简单 O(n) O(1) Swift " }, { "title": "LeetCode - 删除有序数组中的重复项", "url": "/posts/swift-leetcode-0026/", "categories": "代码人生, LeetCode", "tags": "Swift, LeetCode, 算法, 数据结构, 数组", "date": "2021-04-08 12:00:00 +0800", "snippet": "题目链接：删除有序数组中的重复项主要思路定义一个索引index, 遍历数组过程中与该索引的值进行对比，如果不一致，则修改对应索引的值代码实现/** * 时间复杂度: O(n), 空间复杂度: O(1) */class Solution { func removeDuplicates(_ nums: inout [Int]) -&amp;gt; Int { guard nums.count &amp;gt; 0 else { return 0 } var index = 0 for num in nums ..." }, { "title": "LeetCode - 两数之和", "url": "/posts/swift-leetcode-0001/", "categories": "代码人生, LeetCode", "tags": "Swift, LeetCode, 算法, 数据结构, 数组", "date": "2021-04-08 12:00:00 +0800", "snippet": "题目链接：两数之和主要思路遍历数组，并且使用 map 存储 target - nums[i] 的值代码实现/** * 时间复杂度: O(n), 空间复杂度: O(n) */class Solution { func twoSum(_ nums: [Int], _ target: Int) -&amp;gt; [Int] { var dict = [Int: Int]() for (i, num) in nums.enumerated() { if let lastIndex = dict[target - num] { ..." }, { "title": "Swift设计模式概览", "url": "/posts/swift-design-patterns/", "categories": "代码人生, 设计模式", "tags": "Swift, iOS, 设计模式", "date": "2020-05-01 12:00:00 +0800", "snippet": "数据结构与算法教你写出高效的代码，设计模式教你写出高质量的代码创建型模式 工厂方法模式：在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。 抽象工厂模式：让你能创建一系列相关的对象，而无需指定其具体类。 生成器模式：使你能够分步骤创建复杂对象。该模式允许你使用相同的创建代码生成不同类型和形式的对象。 原型模式：使你能够复制已有对象，而又无需使代码依赖它们所属的类。 单例模式：让你能够保证一个类只有一个实例，并提供一个访问该实例的全局节点。 结构型模式 适配器模式：使接口不兼容的对象能够相互合作。 ..." }, { "title": "Swift设计模式之「模板方法模式」", "url": "/posts/swift-design-patterns-template-method/", "categories": "代码人生, 设计模式", "tags": "Swift, iOS, 设计模式", "date": "2020-04-22 12:00:00 +0800", "snippet": "在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。" }, { "title": "Swift设计模式之「策略模式」", "url": "/posts/swift-design-patterns-strategy/", "categories": "代码人生, 设计模式", "tags": "Swift, iOS, 设计模式", "date": "2020-04-21 12:00:00 +0800", "snippet": "在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。" }, { "title": "Swift设计模式之「状态模式」", "url": "/posts/swift-design-patterns-state/", "categories": "代码人生, 设计模式", "tags": "Swift, iOS, 设计模式", "date": "2020-04-20 12:00:00 +0800", "snippet": "在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。" }, { "title": "Swift设计模式之「观察者模式」", "url": "/posts/swift-design-patterns-observer/", "categories": "代码人生, 设计模式", "tags": "Swift, iOS, 设计模式", "date": "2020-04-19 12:00:00 +0800", "snippet": "在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。" }, { "title": "Swift设计模式之「备忘录模式」", "url": "/posts/swift-design-patterns-memento/", "categories": "代码人生, 设计模式", "tags": "Swift, iOS, 设计模式", "date": "2020-04-18 12:00:00 +0800", "snippet": "在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。" }, { "title": "Swift设计模式之「中介者模式」", "url": "/posts/swift-design-patterns-mediator/", "categories": "代码人生, 设计模式", "tags": "Swift, iOS, 设计模式", "date": "2020-04-17 12:00:00 +0800", "snippet": "在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。" }, { "title": "Swift设计模式之「迭代器模式」", "url": "/posts/swift-design-patterns-iterator/", "categories": "代码人生, 设计模式", "tags": "Swift, iOS, 设计模式", "date": "2020-04-16 12:00:00 +0800", "snippet": "在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。" }, { "title": "Swift设计模式之「命令模式」", "url": "/posts/swift-design-patterns-command/", "categories": "代码人生, 设计模式", "tags": "Swift, iOS, 设计模式", "date": "2020-04-15 12:00:00 +0800", "snippet": "在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。" }, { "title": "Swift设计模式之「责任链模式」", "url": "/posts/swift-design-patterns-chain-of-responsibility/", "categories": "代码人生, 设计模式", "tags": "Swift, iOS, 设计模式", "date": "2020-04-14 12:00:00 +0800", "snippet": "在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。" }, { "title": "Swift设计模式之「访问者模式」", "url": "/posts/swift-design-patterns-visitor/", "categories": "代码人生, 设计模式", "tags": "Swift, iOS, 设计模式", "date": "2020-04-13 12:00:00 +0800", "snippet": "在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。" }, { "title": "Swift设计模式之「代理模式」", "url": "/posts/swift-design-patterns-proxy/", "categories": "代码人生, 设计模式", "tags": "Swift, iOS, 设计模式", "date": "2020-04-13 12:00:00 +0800", "snippet": "在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。" }, { "title": "Swift设计模式之「享元模式」", "url": "/posts/swift-design-patterns-flyweight/", "categories": "代码人生, 设计模式", "tags": "Swift, iOS, 设计模式", "date": "2020-04-12 12:00:00 +0800", "snippet": "在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。" }, { "title": "Swift设计模式之「外观模式」", "url": "/posts/swift-design-patterns-facade/", "categories": "代码人生, 设计模式", "tags": "Swift, iOS, 设计模式", "date": "2020-04-11 12:00:00 +0800", "snippet": "在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。" }, { "title": "Swift设计模式之「装饰模式」", "url": "/posts/swift-design-patterns-decorator/", "categories": "代码人生, 设计模式", "tags": "Swift, iOS, 设计模式", "date": "2020-04-10 12:00:00 +0800", "snippet": "在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。" }, { "title": "Swift设计模式之「桥接模式」", "url": "/posts/swift-design-patterns-composite/", "categories": "代码人生, 设计模式", "tags": "Swift, iOS, 设计模式", "date": "2020-04-09 12:00:00 +0800", "snippet": "在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。" }, { "title": "Swift设计模式之「桥接模式」", "url": "/posts/swift-design-patterns-bridge/", "categories": "代码人生, 设计模式", "tags": "Swift, iOS, 设计模式", "date": "2020-04-08 12:00:00 +0800", "snippet": "在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。" }, { "title": "Swift设计模式之「适配器模式」", "url": "/posts/swift-design-patterns-adapter/", "categories": "代码人生, 设计模式", "tags": "Swift, iOS, 设计模式", "date": "2020-04-07 12:00:00 +0800", "snippet": "在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。" }, { "title": "Swift设计模式之「单例模式」", "url": "/posts/swift-design-patterns-singleton/", "categories": "代码人生, 设计模式", "tags": "Swift, iOS, 设计模式", "date": "2020-04-06 12:00:00 +0800", "snippet": "在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。" }, { "title": "Swift设计模式之「原型模式」", "url": "/posts/swift-design-patterns-prototype/", "categories": "代码人生, 设计模式", "tags": "Swift, iOS, 设计模式", "date": "2020-04-05 12:00:00 +0800", "snippet": "在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。" }, { "title": "Swift设计模式之「生成器模式」", "url": "/posts/swift-design-patterns-builder/", "categories": "代码人生, 设计模式", "tags": "Swift, iOS, 设计模式", "date": "2020-04-04 12:00:00 +0800", "snippet": "在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。" }, { "title": "Swift设计模式之「抽象工厂模式」", "url": "/posts/swift-design-patterns-abstract-factory/", "categories": "代码人生, 设计模式", "tags": "Swift, iOS, 设计模式", "date": "2020-04-03 12:00:00 +0800", "snippet": "在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。" }, { "title": "Swift设计模式之「工厂方法模式」", "url": "/posts/swift-design-patterns-factory-method/", "categories": "代码人生, 设计模式", "tags": "Swift, iOS, 设计模式", "date": "2020-04-02 12:00:00 +0800", "snippet": "定义工厂方法模式是一种创建型设计模式，其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。适用场景 编译时无法准确预期要创建的对象的类； 类想让其子类决定在运行时创建什么； 类有若干辅助类为其子类，而你想将返回哪个子类这一信息局部化。 工厂方法模式结构 产品(Product)：将会对接口进行声明。对于所有由创建者及其子类构建的对象，这些接口都是通用的。 具体产品(Concrete Products)：是产品接口的不同实现。 创建者(Creator)：类声明返回产品对象的工厂方法。该方法的返回对象类型..." }, { "title": "Flutter EasyLoading - 让全局Toast/Loading更简单", "url": "/posts/flutter-easyLoading/", "categories": "代码人生, Flutter", "tags": "Flutter, iOS, Android", "date": "2020-02-19 12:00:00 +0800", "snippet": " ✨flutter_easyloading: 一个简单易用的Flutter插件，包含23种loading动画效果、进度条展示、Toast展示。纯Flutter端实现，支持iOS、Android。 ✨开源地址：https://github.com/huangjianke/flutter_easyloading前言Flutter是Google在2017年推出的一套开源跨平台UI框架，可以快速地在iOS、Android和Web平台上构建高质量的原生用户界面。Flutter发布至今，不可谓不说是大受追捧，吸引了大批App原生开发者、Web开发者前赴后继的投入其怀抱，也正由于Flutter是跨..." }, { "title": "「腾讯位置服务」全面拥抱微信小程序，让出行更简单！", "url": "/posts/weapp-loaction/", "categories": "代码人生, 小程序", "tags": "微信小程序, 腾讯位置服务, JavaScript", "date": "2020-01-02 12:00:00 +0800", "snippet": "一、引言1.1「腾讯位置服务」是什么？ 立足生态，连接未来「腾讯位置服务」平台依托庞大的数据生态，以定位、地图展示、地点搜索、路线规划、导航、室内图、海外图等位置服务能力和LBS大数据能力为基础，面向开发者提供方便、易用、高效的LBS服务产品。当前「腾讯位置服务」数据能力已覆盖10亿人的位置行为数据、日均超过600亿次的定位调用、每日支持1亿次位置检索。1.2「腾讯位置服务」可应用的场景？随着功能的日益完善，腾讯位置服务可适用的场景也越来越多，如物流业务、智能出行、o2o业务、共享单车、运动健康、LBS游戏服务等行业均可见「腾讯位置服务」的身影。笔者也将通过此文展示下腾讯位置服务在智能..." }, { "title": "烧脑！JS+Canvas带你体验「偶消奇不消」的智商挑战", "url": "/posts/weapp-game-stack/", "categories": "代码人生, 小程序", "tags": "微信小游戏, JavaScript, Canvas", "date": "2019-09-12 12:00:00 +0800", "snippet": " 启逻辑之高妙，因想象而自由层叠拼图Plus是一款需要空间想象力和逻辑推理能力完美结合的微信小游戏，偶消奇不消，在简单的游戏规则下却有着无数种可能性，需要你充分发挥想象力去探索，看似简单却具有极大的挑战性和趣味性，这就是其魅力所在！游戏界面预览： Talk is cheap. Show me the code层叠拼图Plus微信小游戏采用js+canvas实现，没有使用任何游戏引擎，对于初学者来说，也比较容易入门。接下来，我将通过以下几个点循序渐进的讲解层叠拼图Plus微信小游戏的实现。 如何解决Canvas绘图模糊？ 如何绘制任意多边形图形？ 1 + 1 = 0，「偶消奇不消..." }, { "title": "Gitter - 高颜值GitHub小程序客户端诞生记", "url": "/posts/gitter/", "categories": "代码人生, 小程序", "tags": "Git, 微信小程序", "date": "2019-01-25 12:00:00 +0800", "snippet": "0. 前言嗯，可能一进来大部分人都会觉得，为什么还会有人重复造轮子，GitHub第三方客户端都已经烂大街啦。确实，一开始我自己也是这么觉得的，也问过自己是否真的有意义再去做这样一个项目。思考再三，以下原因也决定了我愿意去做一个让自己满意的GitHub第三方客户端。 对于时常关注GitHub Trending列表的笔者来说，迫切需要一个更简单的方式随时随地去跟随GitHub最新的技术潮流； 已有的一些GitHub小程序客户端颜值与功能并不能满足笔者的要求； 听说iOS开发没人要了，掌握一门新的开发技能，又何尝不可？ 其实也没那么多原因，既..." }, { "title": "iOS自定义对象及子类及模型套模型的拷贝、归档存储的通用代码", "url": "/posts/ios-custom-object-copy-archive/", "categories": "代码人生, iOS", "tags": "iOS", "date": "2018-08-13 12:00:00 +0800", "snippet": "runtime实现通用copy如果自定义类的子类，模型套模型你真的会copy吗，小心有坑。copy需要自定义类继承NSCopying协议#import &amp;lt;objc/runtime.h&amp;gt;- (id)copyWithZone:(NSZone *)zone { id obj = [[[self class] allocWithZone:zone] init]; Class class = [self class]; while (class != [NSObject class]) { unsigned int count; ..." }, { "title": "Git仓库迁移保留提交记录", "url": "/posts/git-history/", "categories": "Git", "tags": "Git, 杂谈", "date": "2018-07-22 12:00:00 +0800", "snippet": " 最近需要迁移Git仓库，有如下需求 保留原有仓库的分支 保留原有仓库的提交记录通过查找资料，最后发现一种最优Git仓库迁移方案。 先 clone 原有仓库的镜像 git clone --mirror old.git (old.git为原有仓库Git地址) 进入原有仓库目录 cd old.git 修改原有仓库地址为新仓库地址 git remote set-url --push origin new.git(new.git 为新项目的Git地址) 推送镜像到远程 git push --mirror 需要输入..." } ]
