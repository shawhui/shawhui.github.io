<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="烧脑！JS+Canvas带你体验「偶消奇不消」的智商挑战" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="启逻辑之高妙，因想象而自由 层叠拼图Plus是一款需要空间想象力和逻辑推理能力完美结合的微信小游戏，偶消奇不消，在简单的游戏规则下却有着无数种可能性，需要你充分发挥想象力去探索，看似简单却具有极大的挑战性和趣味性，这就是其魅力所在！ 游戏界面预览： Talk is cheap. Show me the code 层叠拼图Plus微信小游戏采用js+canvas实现，没有使用任何游戏引擎，对于初学者来说，也比较容易入门。接下来，我将通过以下几个点循序渐进的讲解层叠拼图Plus微信小游戏的实现。 如何解决Canvas绘图模糊？ 如何绘制任意多边形图形？ 1 + 1 = 0，「偶消奇不消」的效果如何实现？ 如何判断一个点是否在任意多边形内部 ？ 如何判断游戏结果是否正确？ 排行榜的展示 游戏性能优化 如何解决Canvas绘图模糊？ canvas 绘图时，会从两个物理像素的中间位置开始绘制并向两边扩散 0.5 个物理像素。当设备像素比为 1 时，一个 1px 的线条实际上占据了两个物理像素（每个像素实际上只占一半），由于不存在 0.5 个像素，所以这两个像素本来不应该被绘制的部分也被绘制了，于是 1 物理像素的线条变成了 2 物理像素，视觉上就造成了模糊 绘图模糊的原因知道了，在微信小游戏里面又该如何解决呢？ 1 2 3 4 5 6 7 8 9 10 11 const ratio = wx.getSystemInfoSync().pixelRatio let ctx = canvas.getContext(&#39;2d&#39;) canvas.width = screenWidth * ratio canvas.height = screenHeight * ratio ctx.fillStyle = &#39;black&#39; ctx.font = `${18 * ratio}px Arial` ctx.fillText(&#39;我是清晰的文字&#39;, x * ratio, y * ratio) ctx.fillStyle = &#39;red&#39; ctx.fillRect(x * ratio, y * ratio, width * ratio, height * ratio) 可以看到，我们先通过 wx.getSystemInfoSync().pixelRatio 获取设备的像素比ratio，然后将在屏 Canvas 的宽度和高度按照所获取的像素比ratio进行放大，在绘制文字、图片的时候，坐标点 x、y 和所要绘制图形的 width、height均需要按照像素比 ratio 进行缩放，这样我们就可以清晰的在高清屏中绘制想要的文字、图片。 可参考微信官方 缩放策略调整 另外，需要注意的是，这里的 canvas 是由 weapp-adapter 预先调用 wx.createCanvas() 创建一个上屏 Canvas，并暴露为一个全局变量 canvas。 如何绘制任意多边形图形？ 任意一个多边形图形，是由多个平面坐标点所组成的图形区域。 在游戏画布内，我们以左上角为坐标原点 {x: 0, y: 0} ，一个多边形包含多个单位长度的平面坐标点，如：[{ x: 1, y: 3 }, { x: 5, y: 3 }, { x: 3, y: 5 }] 表示为一个三角形的区域，需要注意的是，x、y 并不是真实的平面坐标值，而是通过屏幕宽度计算出来的单位长度，在画布内的真实坐标值则为 {x: x * itemWidth, y: y * itemWidth} 。 绘制多边形代码实现如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /** * 绘制多边形 */ export default class Block { constructor() { } init(points, itemWidth, ctx) { this.points = [] this.itemWidth = itemWidth // 单位长度 this.ctx = ctx for (let i = 0; i &lt; points.length; i++) { let point = points[i] this.points.push({ x: point.x * this.itemWidth, y: point.y * this.itemWidth }) } } draw() { this.ctx.globalCompositeOperation = &#39;xor&#39; this.ctx.fillStyle = &#39;black&#39; this.ctx.beginPath() this.ctx.moveTo(this.points[0].x, this.points[0].y) for (let i = 1; i &lt; this.points.length; i++) { let point = this.points[i] this.ctx.lineTo(point.x, point.y) } this.ctx.closePath() this.ctx.fill() } } 使用： 1 2 3 4 5 6 7 8 9 10 let points = [ [{ x: 4, y: 5 }, { x: 8, y: 9 }, { x: 4, y: 9 }], [{ x: 10, y: 8 }, { x: 10, y: 12 }, { x: 6, y: 12 }], [{ x: 7, y: 4 }, { x: 11, y: 4 }, { x: 11, y: 8 }] ] points.map((sub_points) =&gt; { let block = new Block() block.init(sub_points, this.itemWidth, this.ctx) block.draw() }) 效果如下图： CanvasRenderingContext2D其他使用方法可参考：CanvasRenderingContext2D API 列表 1 + 1 = 0，「偶消奇不消」的效果如何实现？ 1 + 1 = 0，是层叠拼图Plus小游戏玩法的精髓所在。 有经验的同学，也许一眼就发现了，1 + 1 = 0 刚好符合通过 异或运算 得出的结果。当然，细心的同学也可能已经发现，在 如何绘制任意多边形图形 这一章节内，有一句特殊的代码：this.ctx.globalCompositeOperation = &#39;xor&#39;，也正是通过设置 CanvasContext 的 globalCompositeOperation 属性值为 xor 便实现了「偶消奇不消」的神奇效果。 globalCompositeOperation 是指 在绘制新形状时应用的合成操作的类型，其他效果可参考：globalCompositeOperation 示例 如何判断一个点是否在任意多边形内部？ 当回转数为 0 时，点在闭合曲线外部。 讲到这里，我们已经知道如何在Canvas画布内绘制出偶消奇不消效果的层叠图形了，接下来我们来看下玩家如何移动选中的图形。我们发现绘制出的图形对象并没有提供点击事件绑定之类的操作，那又如何判断玩家选中了哪个图形呢？这里我们就需要去实现如何判断玩家触摸事件的x，y坐标在哪个多边形图形内部区域，从而判断出玩家选中的是哪一个多边形图形。 判断一个点是否在任意多边形内部有多种方法，比如： 射线法 面积判别法 叉乘判别法 回转数法 … 在层叠拼图Plus小游戏内，采用的是 回转数 法来判断玩家触摸点是否在多边形内部。回转数 是拓扑学中的一个基本概念，具有很重要的性质和用途。当然，展开讨论 回转数 的概念并不在该文的讨论范围内，我们仅需了解一个概念：当回转数为 0 时，点在闭合曲线外部。 上面面这张图动态演示了回转数的概念：图中红色曲线关于点（人所在位置）的回转数为 2。 对于给定的点和多边形，回转数应该怎么计算呢？ 用线段分别连接点和多边形的全部顶点 计算所有点与相邻顶点连线的夹角 计算所有夹角和。注意每个夹角都是有方向的，所以有可能是负值 最后根据角度累加值计算回转数。360°（2π）相当于一次回转。 在使用 JavaScript 实现时，需要注意以下问题： JavaScript 的数只有 64 位双精度浮点这一种。对于三角函数产生的无理数，浮点数计算不可避免会造成一些误差，因此在最后计算回转数需要做取整操作。 通常情况下，平面直角坐标系内一个角的取值范围是 -π 到 π 这个区间，这也是 JavaScript 三角函数 Math.atan2() 返回值的范围。但 JavaScript 并不能直接计算任意两条线的夹角，我们只能先计算两条线与 x 正轴夹角，再取两者差值。这个差值的结果就有可能超出 -π 到 π 这个区间，因此我们还需要处理差值超出取值区间的情况。 代码实现： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /** * 判断点是否在多边形内/边上 */ isPointInPolygon(p, poly) { let px = p.x, py = p.y, sum = 0 for (let i = 0, l = poly.length, j = l - 1; i &lt; l; j = i, i++) { let sx = poly[i].x, sy = poly[i].y, tx = poly[j].x, ty = poly[j].y // 点与多边形顶点重合或在多边形的边上 if ((sx - px) * (px - tx) &gt;= 0 &amp;&amp; (sy - py) * (py - ty) &gt;= 0 &amp;&amp; (px - sx) * (ty - sy) === (py - sy) * (tx - sx)) { return true } // 点与相邻顶点连线的夹角 let angle = Math.atan2(sy - py, sx - px) - Math.atan2(ty - py, tx - px) // 确保夹角不超出取值范围（-π 到 π） if (angle &gt;= Math.PI) { angle = angle - Math.PI * 2 } else if (angle &lt;= -Math.PI) { angle = angle + Math.PI * 2 } sum += angle } // 计算回转数并判断点和多边形的几何关系 return Math.round(sum / Math.PI) === 0 ? false : true } 注：该章节内容图片均来自网络，如有侵权，请告知删除。另外有兴趣的同学可以使用其他方法来实现判断一个点是否在任意多边形内部。 如何判断游戏结果是否正确？ 探索的过程固然精彩，而结果却更令我们期待 通过前面的介绍我们可以知道，判断游戏结果是否正确其实就是比对玩家组合图形的 xor 结果与目标图形的 xor 结果。那么如何求多个多边形 xor 的结果呢？ polygon-clipping 正是为此而生的。它不仅支持 xor 操作，还有其他的比如：union, intersection, difference 等操作。 在层叠拼图Plus游戏内通过 polygon-clipping 又是怎样实现游戏结果判断的呢？ 目标图形 多边形平面坐标点集合： 1 2 3 4 points = [ [{ x: 6, y: 6 }, { x: 10, y: 6 }, { x: 10, y: 10 }, { x: 6, y: 10 }], [{ x: 8, y: 6 }, { x: 10, y: 8 }, { x: 8, y: 10 }, { x: 6, y: 8 }] ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /** * 获取 多个多边形 xor 结果 */ const polygonClipping = require(&#39;polygon-clipping&#39;) polygonXor(points) { let poly = [] points.forEach(function (sub_points) { let temp = [] sub_points.forEach(function (point) { temp.push([point.x, point.y]) }) poly.push([temp]) }) let results = polygonClipping.xor(...poly) // 找出左上角的点 let min_x = 100, min_y = 100 results.forEach(function (sub_results) { sub_results.forEach(function (temps) { temps.forEach(function (point) { if (point[0] &lt; min_x) min_x = point[0] if (point[1] &lt; min_y) min_y = point[1] }) }) }) // 以左上角为参考点 多边形平移至 原点 {x: 0, y: 0} results.forEach(function (sub_results) { sub_results.forEach(function (temps) { temps.forEach(function (point) { point[0] -= min_x point[1] -= min_y }) }) }) } xor结果： 1 2 3 4 5 6 7 let result = this.polygonXor(points) result = [ [[[0, 0], [2, 0], [0, 2], [0, 0]]], [[[0, 2], [2, 4], [0, 4], [0, 2]]], [[[2, 0], [4, 0], [4, 2], [2, 0]]], [[[2, 4], [4, 2], [4, 4], [2, 4]]] ] 同理计算出玩家操作图形的xor结果进行比对即可得出答案正确与否。 需要注意的是，获取玩家的 xor 结果并不能直接拿来与目标图形xor 结果进行比较，我们需要将xor 的结果以左上角为参考点将图形平移至原点内，然后再进行比较，如果结果一致，则代表玩家答案正确。 排行榜的展示 有人的地方就有江湖，有江湖的地方就有排行 在看本章节内容之前，建议先浏览一遍排行榜相关的官方文档：好友排行榜、关系链数据，以便对相关内容有个大概的了解。 开放数据域 开放数据域是一个封闭、独立的 JavaScript 作用域。要让代码运行在开放数据域，需要在 game.json 中添加配置项 openDataContext 指定开放数据域的代码目录。添加该配置项表示小游戏启用了开放数据域，这将会导致一些限制。 1 2 3 4 // game.json { &quot;openDataContext&quot;: &quot;src/myOpenDataContext&quot; } 在游戏内使用 wx.setUserCloudStorage(obj) 对玩家游戏数据进行托管。 在开放数据域内使用 wx.getFriendCloudStorage(obj)拉取当前用户所有同玩好友的托管数据 展示关系链数据 如果想要展示通过关系链 API 获取到的用户数据，如绘制排行榜等业务场景，需要将排行榜绘制到 sharedCanvas 上，再在主域将 sharedCanvas 渲染上屏。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/myOpenDataContext/index.js let sharedCanvas = wx.getSharedCanvas() function drawRankList (data) { data.forEach((item, index) =&gt; { // ... }) } wx.getFriendCloudStorage({ success: res =&gt; { let data = res.data drawRankList(data) } }) sharedCanvas 是主域和开放数据域都可以访问的一个离屏画布。在开放数据域调用 wx.getSharedCanvas() 将返回 sharedCanvas。 1 2 3 4 5 // src/myOpenDataContext/index.js let sharedCanvas = wx.getSharedCanvas() let context = sharedCanvas.getContext(&#39;2d&#39;) context.fillStyle = &#39;red&#39; context.fillRect(0, 0, 100, 100) 在主域中可以通过开放数据域实例访问 sharedCanvas，通过 drawImage() 方法可以将 sharedCanvas 绘制到上屏画布。 1 2 3 4 5 6 7 // game.js let openDataContext = wx.getOpenDataContext() let sharedCanvas = openDataContext.canvas let canvas = wx.createCanvas() let context = canvas.getContext(&#39;2d&#39;) context.drawImage(sharedCanvas, 0, 0) sharedCanvas 本质上也是一个离屏 Canvas，而重设 Canvas 的宽高会清空 Canvas 上的内容。所以要通知开放数据域去重绘 sharedCanvas。 1 2 3 4 5 6 7 8 9 10 11 // game.js openDataContext.postMessage({ command: &#39;render&#39; }) // src/myOpenDataContext/index.js openDataContext.onMessage(data =&gt; { if (data.command === &#39;render&#39;) { // 重绘 sharedCanvas } }) 需要注意的是：sharedCanvas 的宽高只能在主域设置，不能在开放数据域中设置。 游戏性能优化 性能优化，简而言之，就是在不影响系统运行正确性的前提下，使之运行地更快，完成特定功能所需的时间更短。 一款能让人心情愉悦的游戏，性能问题必然不能成为绊脚石。那么可以从哪些方面对游戏进行性能优化呢？ 离屏 Canvas 在层叠拼图Plus小游戏内，针对需要大量使用且绘图繁复的静态场景，都是使用离屏 Canvas进行绘制的，如首页网格背景、关卡列表、排名列表等。在微信内 wx.createCanvas() 首次调用创建的是显示在屏幕上的画布，之后调用创建的都是离屏画布。初始化时将静态场景绘制完备，需要时直接拷贝离屏Canvas的图像即可。Canvas 绘制本身就是不断的更新帧从而达到动画的效果，通过使用离屏 Canvas，就大大减少了一些静态内容在上屏Canvas的绘制，从而提升了绘制性能。 1 2 3 4 5 this.offScreenCanvas = wx.createCanvas() this.offScreenCanvas.width = this.width * ratio this.offScreenCanvas.height = this.height * ratio this.ctx.drawImage(this.offScreenCanvas, x * ratio, y * ratio, this.offScreenCanvas.width, this.offScreenCanvas.height) 内存优化 玩家在游戏过程中拖动方块的移动其实就是不断更新多边形图形的坐标信息，然后不断的清空画布再重新绘制，可以想象，这个绘制是非常频繁的，按照普通的做法就需要不断去创建多个新的 Block 对象。针对游戏中需要频繁更新的对象，我们可以通过使用对象池的方法进行优化，对象池维护一个装着空闲对象的池子，如果需要对象的时候，不是直接new，而是从对象池中取出，如果对象池中没有空闲对象，则新建一个空闲对象，层叠拼图Plus小游戏内使用的是官方demo内已经实现的对象池类，实现如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 const __ = { poolDic: Symbol(&#39;poolDic&#39;) } /** * 简易的对象池实现 * 用于对象的存贮和重复使用 * 可以有效减少对象创建开销和避免频繁的垃圾回收 * 提高游戏性能 */ export default class Pool { constructor() { this[__.poolDic] = {} } /** * 根据对象标识符 * 获取对应的对象池 */ getPoolBySign(name) { return this[__.poolDic][name] || ( this[__.poolDic][name] = [] ) } /** * 根据传入的对象标识符，查询对象池 * 对象池为空创建新的类，否则从对象池中取 */ getItemByClass(name, className) { let pool = this.getPoolBySign(name) let result = ( pool.length ? pool.shift() : new className() ) return result } /** * 将对象回收到对象池 * 方便后续继续使用 */ recover(name, instance) { this.getPoolBySign(name).push(instance) } } 垃圾回收 小游戏中，JavaScript 中的每一个 Canvas 或 Image 对象都会有一个客户端层的实际纹理储存，实际纹理储存中存放着 Canvas、Image 的真实纹理，通常会占用相当一部分内存。 每个客户端实际纹理储存的回收时机依赖于 JavaScript 中的 Canvas、Image 对象回收。在 JavaScript 的 Canvas、Image 对象被回收之前，客户端对应的实际纹理储存不会被回收。通过调用 wx.triggerGC() 方法，可以加快触发 JavaScriptCore Garbage Collection（垃圾回收），从而触发 JavaScript 中没有引用的 Canvas、Image 回收，释放对应的实际纹理储存。 但 GC 具体触发时机还要取决于 JavaScriptCore 自身机制，并不能保证调用 wx.triggerGC() 能马上触发回收，层叠拼图Plus小游戏在每局游戏开始或结束都会触发一下，及时回收内存垃圾，以保证最良好的游戏体验。 多线程 Worker 对于游戏来说，每帧 16ms 是极其宝贵的，如果有一些可以异步处理的任务，可以放置于 Worker 中运行，待运行结束后，再把结果返回到主线程。Worker 运行于一个单独的全局上下文与线程中，不能直接调用主线程的方法，Worker 也不具备渲染的能力。 Worker与主线程之间的数据传输，双方使用 Worker.postMessage() 来发送数据，Worker.onMessage() 来接收数据，传输的数据并不是直接共享，而是被复制的。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // game.json { &quot;workers&quot;: &quot;workers&quot; } // 创建worker线程 let worker = worker = wx.createWorker(&#39;workers/request/index.js&#39;) // 文件名指定 worker 的入口文件路径，绝对路径 // 主线程向 Worker 发送消息 worker.postMessage({ msg: &#39;hello worker&#39; }) // 主线程监听 Worker 返回消息 worker.onMessage(function (res) { console.log(res) }) 需要注意的是：Worker 最大并发数量限制为 1 个，创建下一个前请用 Worker.terminate() 结束当前 Worker 其他 Worker 相关的内容请参考微信官方文档：多线程 Worker 结语 短短的一篇文章，定不能将层叠拼图Plus小游戏的前前后后讲明白讲透彻，加上文笔有限，有描述不当的地方还望多多海涵。其实最让人心累的还是软著的申请过程，由于各种原因前前后后花了将近三个月的时间，本来也想写一下软著申请相关的内容，最后发现篇幅有点长，无奈作罢，争取后面花点时间整理一下我这边的经验，希望可以帮助到需要的童鞋。 由于项目结构以及代码还比较混乱，个人觉得，目前暂时还不适合开源。好在，小游戏内的所有核心代码以及游戏实现思想均已呈上，有兴趣的同学如果有相关方面的疑问也可以与我多多交流，大家互相学习，共同进步。 体验游戏： 江湖不远，我们游戏里见！" /><meta property="og:description" content="启逻辑之高妙，因想象而自由 层叠拼图Plus是一款需要空间想象力和逻辑推理能力完美结合的微信小游戏，偶消奇不消，在简单的游戏规则下却有着无数种可能性，需要你充分发挥想象力去探索，看似简单却具有极大的挑战性和趣味性，这就是其魅力所在！ 游戏界面预览： Talk is cheap. Show me the code 层叠拼图Plus微信小游戏采用js+canvas实现，没有使用任何游戏引擎，对于初学者来说，也比较容易入门。接下来，我将通过以下几个点循序渐进的讲解层叠拼图Plus微信小游戏的实现。 如何解决Canvas绘图模糊？ 如何绘制任意多边形图形？ 1 + 1 = 0，「偶消奇不消」的效果如何实现？ 如何判断一个点是否在任意多边形内部 ？ 如何判断游戏结果是否正确？ 排行榜的展示 游戏性能优化 如何解决Canvas绘图模糊？ canvas 绘图时，会从两个物理像素的中间位置开始绘制并向两边扩散 0.5 个物理像素。当设备像素比为 1 时，一个 1px 的线条实际上占据了两个物理像素（每个像素实际上只占一半），由于不存在 0.5 个像素，所以这两个像素本来不应该被绘制的部分也被绘制了，于是 1 物理像素的线条变成了 2 物理像素，视觉上就造成了模糊 绘图模糊的原因知道了，在微信小游戏里面又该如何解决呢？ 1 2 3 4 5 6 7 8 9 10 11 const ratio = wx.getSystemInfoSync().pixelRatio let ctx = canvas.getContext(&#39;2d&#39;) canvas.width = screenWidth * ratio canvas.height = screenHeight * ratio ctx.fillStyle = &#39;black&#39; ctx.font = `${18 * ratio}px Arial` ctx.fillText(&#39;我是清晰的文字&#39;, x * ratio, y * ratio) ctx.fillStyle = &#39;red&#39; ctx.fillRect(x * ratio, y * ratio, width * ratio, height * ratio) 可以看到，我们先通过 wx.getSystemInfoSync().pixelRatio 获取设备的像素比ratio，然后将在屏 Canvas 的宽度和高度按照所获取的像素比ratio进行放大，在绘制文字、图片的时候，坐标点 x、y 和所要绘制图形的 width、height均需要按照像素比 ratio 进行缩放，这样我们就可以清晰的在高清屏中绘制想要的文字、图片。 可参考微信官方 缩放策略调整 另外，需要注意的是，这里的 canvas 是由 weapp-adapter 预先调用 wx.createCanvas() 创建一个上屏 Canvas，并暴露为一个全局变量 canvas。 如何绘制任意多边形图形？ 任意一个多边形图形，是由多个平面坐标点所组成的图形区域。 在游戏画布内，我们以左上角为坐标原点 {x: 0, y: 0} ，一个多边形包含多个单位长度的平面坐标点，如：[{ x: 1, y: 3 }, { x: 5, y: 3 }, { x: 3, y: 5 }] 表示为一个三角形的区域，需要注意的是，x、y 并不是真实的平面坐标值，而是通过屏幕宽度计算出来的单位长度，在画布内的真实坐标值则为 {x: x * itemWidth, y: y * itemWidth} 。 绘制多边形代码实现如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /** * 绘制多边形 */ export default class Block { constructor() { } init(points, itemWidth, ctx) { this.points = [] this.itemWidth = itemWidth // 单位长度 this.ctx = ctx for (let i = 0; i &lt; points.length; i++) { let point = points[i] this.points.push({ x: point.x * this.itemWidth, y: point.y * this.itemWidth }) } } draw() { this.ctx.globalCompositeOperation = &#39;xor&#39; this.ctx.fillStyle = &#39;black&#39; this.ctx.beginPath() this.ctx.moveTo(this.points[0].x, this.points[0].y) for (let i = 1; i &lt; this.points.length; i++) { let point = this.points[i] this.ctx.lineTo(point.x, point.y) } this.ctx.closePath() this.ctx.fill() } } 使用： 1 2 3 4 5 6 7 8 9 10 let points = [ [{ x: 4, y: 5 }, { x: 8, y: 9 }, { x: 4, y: 9 }], [{ x: 10, y: 8 }, { x: 10, y: 12 }, { x: 6, y: 12 }], [{ x: 7, y: 4 }, { x: 11, y: 4 }, { x: 11, y: 8 }] ] points.map((sub_points) =&gt; { let block = new Block() block.init(sub_points, this.itemWidth, this.ctx) block.draw() }) 效果如下图： CanvasRenderingContext2D其他使用方法可参考：CanvasRenderingContext2D API 列表 1 + 1 = 0，「偶消奇不消」的效果如何实现？ 1 + 1 = 0，是层叠拼图Plus小游戏玩法的精髓所在。 有经验的同学，也许一眼就发现了，1 + 1 = 0 刚好符合通过 异或运算 得出的结果。当然，细心的同学也可能已经发现，在 如何绘制任意多边形图形 这一章节内，有一句特殊的代码：this.ctx.globalCompositeOperation = &#39;xor&#39;，也正是通过设置 CanvasContext 的 globalCompositeOperation 属性值为 xor 便实现了「偶消奇不消」的神奇效果。 globalCompositeOperation 是指 在绘制新形状时应用的合成操作的类型，其他效果可参考：globalCompositeOperation 示例 如何判断一个点是否在任意多边形内部？ 当回转数为 0 时，点在闭合曲线外部。 讲到这里，我们已经知道如何在Canvas画布内绘制出偶消奇不消效果的层叠图形了，接下来我们来看下玩家如何移动选中的图形。我们发现绘制出的图形对象并没有提供点击事件绑定之类的操作，那又如何判断玩家选中了哪个图形呢？这里我们就需要去实现如何判断玩家触摸事件的x，y坐标在哪个多边形图形内部区域，从而判断出玩家选中的是哪一个多边形图形。 判断一个点是否在任意多边形内部有多种方法，比如： 射线法 面积判别法 叉乘判别法 回转数法 … 在层叠拼图Plus小游戏内，采用的是 回转数 法来判断玩家触摸点是否在多边形内部。回转数 是拓扑学中的一个基本概念，具有很重要的性质和用途。当然，展开讨论 回转数 的概念并不在该文的讨论范围内，我们仅需了解一个概念：当回转数为 0 时，点在闭合曲线外部。 上面面这张图动态演示了回转数的概念：图中红色曲线关于点（人所在位置）的回转数为 2。 对于给定的点和多边形，回转数应该怎么计算呢？ 用线段分别连接点和多边形的全部顶点 计算所有点与相邻顶点连线的夹角 计算所有夹角和。注意每个夹角都是有方向的，所以有可能是负值 最后根据角度累加值计算回转数。360°（2π）相当于一次回转。 在使用 JavaScript 实现时，需要注意以下问题： JavaScript 的数只有 64 位双精度浮点这一种。对于三角函数产生的无理数，浮点数计算不可避免会造成一些误差，因此在最后计算回转数需要做取整操作。 通常情况下，平面直角坐标系内一个角的取值范围是 -π 到 π 这个区间，这也是 JavaScript 三角函数 Math.atan2() 返回值的范围。但 JavaScript 并不能直接计算任意两条线的夹角，我们只能先计算两条线与 x 正轴夹角，再取两者差值。这个差值的结果就有可能超出 -π 到 π 这个区间，因此我们还需要处理差值超出取值区间的情况。 代码实现： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /** * 判断点是否在多边形内/边上 */ isPointInPolygon(p, poly) { let px = p.x, py = p.y, sum = 0 for (let i = 0, l = poly.length, j = l - 1; i &lt; l; j = i, i++) { let sx = poly[i].x, sy = poly[i].y, tx = poly[j].x, ty = poly[j].y // 点与多边形顶点重合或在多边形的边上 if ((sx - px) * (px - tx) &gt;= 0 &amp;&amp; (sy - py) * (py - ty) &gt;= 0 &amp;&amp; (px - sx) * (ty - sy) === (py - sy) * (tx - sx)) { return true } // 点与相邻顶点连线的夹角 let angle = Math.atan2(sy - py, sx - px) - Math.atan2(ty - py, tx - px) // 确保夹角不超出取值范围（-π 到 π） if (angle &gt;= Math.PI) { angle = angle - Math.PI * 2 } else if (angle &lt;= -Math.PI) { angle = angle + Math.PI * 2 } sum += angle } // 计算回转数并判断点和多边形的几何关系 return Math.round(sum / Math.PI) === 0 ? false : true } 注：该章节内容图片均来自网络，如有侵权，请告知删除。另外有兴趣的同学可以使用其他方法来实现判断一个点是否在任意多边形内部。 如何判断游戏结果是否正确？ 探索的过程固然精彩，而结果却更令我们期待 通过前面的介绍我们可以知道，判断游戏结果是否正确其实就是比对玩家组合图形的 xor 结果与目标图形的 xor 结果。那么如何求多个多边形 xor 的结果呢？ polygon-clipping 正是为此而生的。它不仅支持 xor 操作，还有其他的比如：union, intersection, difference 等操作。 在层叠拼图Plus游戏内通过 polygon-clipping 又是怎样实现游戏结果判断的呢？ 目标图形 多边形平面坐标点集合： 1 2 3 4 points = [ [{ x: 6, y: 6 }, { x: 10, y: 6 }, { x: 10, y: 10 }, { x: 6, y: 10 }], [{ x: 8, y: 6 }, { x: 10, y: 8 }, { x: 8, y: 10 }, { x: 6, y: 8 }] ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /** * 获取 多个多边形 xor 结果 */ const polygonClipping = require(&#39;polygon-clipping&#39;) polygonXor(points) { let poly = [] points.forEach(function (sub_points) { let temp = [] sub_points.forEach(function (point) { temp.push([point.x, point.y]) }) poly.push([temp]) }) let results = polygonClipping.xor(...poly) // 找出左上角的点 let min_x = 100, min_y = 100 results.forEach(function (sub_results) { sub_results.forEach(function (temps) { temps.forEach(function (point) { if (point[0] &lt; min_x) min_x = point[0] if (point[1] &lt; min_y) min_y = point[1] }) }) }) // 以左上角为参考点 多边形平移至 原点 {x: 0, y: 0} results.forEach(function (sub_results) { sub_results.forEach(function (temps) { temps.forEach(function (point) { point[0] -= min_x point[1] -= min_y }) }) }) } xor结果： 1 2 3 4 5 6 7 let result = this.polygonXor(points) result = [ [[[0, 0], [2, 0], [0, 2], [0, 0]]], [[[0, 2], [2, 4], [0, 4], [0, 2]]], [[[2, 0], [4, 0], [4, 2], [2, 0]]], [[[2, 4], [4, 2], [4, 4], [2, 4]]] ] 同理计算出玩家操作图形的xor结果进行比对即可得出答案正确与否。 需要注意的是，获取玩家的 xor 结果并不能直接拿来与目标图形xor 结果进行比较，我们需要将xor 的结果以左上角为参考点将图形平移至原点内，然后再进行比较，如果结果一致，则代表玩家答案正确。 排行榜的展示 有人的地方就有江湖，有江湖的地方就有排行 在看本章节内容之前，建议先浏览一遍排行榜相关的官方文档：好友排行榜、关系链数据，以便对相关内容有个大概的了解。 开放数据域 开放数据域是一个封闭、独立的 JavaScript 作用域。要让代码运行在开放数据域，需要在 game.json 中添加配置项 openDataContext 指定开放数据域的代码目录。添加该配置项表示小游戏启用了开放数据域，这将会导致一些限制。 1 2 3 4 // game.json { &quot;openDataContext&quot;: &quot;src/myOpenDataContext&quot; } 在游戏内使用 wx.setUserCloudStorage(obj) 对玩家游戏数据进行托管。 在开放数据域内使用 wx.getFriendCloudStorage(obj)拉取当前用户所有同玩好友的托管数据 展示关系链数据 如果想要展示通过关系链 API 获取到的用户数据，如绘制排行榜等业务场景，需要将排行榜绘制到 sharedCanvas 上，再在主域将 sharedCanvas 渲染上屏。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/myOpenDataContext/index.js let sharedCanvas = wx.getSharedCanvas() function drawRankList (data) { data.forEach((item, index) =&gt; { // ... }) } wx.getFriendCloudStorage({ success: res =&gt; { let data = res.data drawRankList(data) } }) sharedCanvas 是主域和开放数据域都可以访问的一个离屏画布。在开放数据域调用 wx.getSharedCanvas() 将返回 sharedCanvas。 1 2 3 4 5 // src/myOpenDataContext/index.js let sharedCanvas = wx.getSharedCanvas() let context = sharedCanvas.getContext(&#39;2d&#39;) context.fillStyle = &#39;red&#39; context.fillRect(0, 0, 100, 100) 在主域中可以通过开放数据域实例访问 sharedCanvas，通过 drawImage() 方法可以将 sharedCanvas 绘制到上屏画布。 1 2 3 4 5 6 7 // game.js let openDataContext = wx.getOpenDataContext() let sharedCanvas = openDataContext.canvas let canvas = wx.createCanvas() let context = canvas.getContext(&#39;2d&#39;) context.drawImage(sharedCanvas, 0, 0) sharedCanvas 本质上也是一个离屏 Canvas，而重设 Canvas 的宽高会清空 Canvas 上的内容。所以要通知开放数据域去重绘 sharedCanvas。 1 2 3 4 5 6 7 8 9 10 11 // game.js openDataContext.postMessage({ command: &#39;render&#39; }) // src/myOpenDataContext/index.js openDataContext.onMessage(data =&gt; { if (data.command === &#39;render&#39;) { // 重绘 sharedCanvas } }) 需要注意的是：sharedCanvas 的宽高只能在主域设置，不能在开放数据域中设置。 游戏性能优化 性能优化，简而言之，就是在不影响系统运行正确性的前提下，使之运行地更快，完成特定功能所需的时间更短。 一款能让人心情愉悦的游戏，性能问题必然不能成为绊脚石。那么可以从哪些方面对游戏进行性能优化呢？ 离屏 Canvas 在层叠拼图Plus小游戏内，针对需要大量使用且绘图繁复的静态场景，都是使用离屏 Canvas进行绘制的，如首页网格背景、关卡列表、排名列表等。在微信内 wx.createCanvas() 首次调用创建的是显示在屏幕上的画布，之后调用创建的都是离屏画布。初始化时将静态场景绘制完备，需要时直接拷贝离屏Canvas的图像即可。Canvas 绘制本身就是不断的更新帧从而达到动画的效果，通过使用离屏 Canvas，就大大减少了一些静态内容在上屏Canvas的绘制，从而提升了绘制性能。 1 2 3 4 5 this.offScreenCanvas = wx.createCanvas() this.offScreenCanvas.width = this.width * ratio this.offScreenCanvas.height = this.height * ratio this.ctx.drawImage(this.offScreenCanvas, x * ratio, y * ratio, this.offScreenCanvas.width, this.offScreenCanvas.height) 内存优化 玩家在游戏过程中拖动方块的移动其实就是不断更新多边形图形的坐标信息，然后不断的清空画布再重新绘制，可以想象，这个绘制是非常频繁的，按照普通的做法就需要不断去创建多个新的 Block 对象。针对游戏中需要频繁更新的对象，我们可以通过使用对象池的方法进行优化，对象池维护一个装着空闲对象的池子，如果需要对象的时候，不是直接new，而是从对象池中取出，如果对象池中没有空闲对象，则新建一个空闲对象，层叠拼图Plus小游戏内使用的是官方demo内已经实现的对象池类，实现如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 const __ = { poolDic: Symbol(&#39;poolDic&#39;) } /** * 简易的对象池实现 * 用于对象的存贮和重复使用 * 可以有效减少对象创建开销和避免频繁的垃圾回收 * 提高游戏性能 */ export default class Pool { constructor() { this[__.poolDic] = {} } /** * 根据对象标识符 * 获取对应的对象池 */ getPoolBySign(name) { return this[__.poolDic][name] || ( this[__.poolDic][name] = [] ) } /** * 根据传入的对象标识符，查询对象池 * 对象池为空创建新的类，否则从对象池中取 */ getItemByClass(name, className) { let pool = this.getPoolBySign(name) let result = ( pool.length ? pool.shift() : new className() ) return result } /** * 将对象回收到对象池 * 方便后续继续使用 */ recover(name, instance) { this.getPoolBySign(name).push(instance) } } 垃圾回收 小游戏中，JavaScript 中的每一个 Canvas 或 Image 对象都会有一个客户端层的实际纹理储存，实际纹理储存中存放着 Canvas、Image 的真实纹理，通常会占用相当一部分内存。 每个客户端实际纹理储存的回收时机依赖于 JavaScript 中的 Canvas、Image 对象回收。在 JavaScript 的 Canvas、Image 对象被回收之前，客户端对应的实际纹理储存不会被回收。通过调用 wx.triggerGC() 方法，可以加快触发 JavaScriptCore Garbage Collection（垃圾回收），从而触发 JavaScript 中没有引用的 Canvas、Image 回收，释放对应的实际纹理储存。 但 GC 具体触发时机还要取决于 JavaScriptCore 自身机制，并不能保证调用 wx.triggerGC() 能马上触发回收，层叠拼图Plus小游戏在每局游戏开始或结束都会触发一下，及时回收内存垃圾，以保证最良好的游戏体验。 多线程 Worker 对于游戏来说，每帧 16ms 是极其宝贵的，如果有一些可以异步处理的任务，可以放置于 Worker 中运行，待运行结束后，再把结果返回到主线程。Worker 运行于一个单独的全局上下文与线程中，不能直接调用主线程的方法，Worker 也不具备渲染的能力。 Worker与主线程之间的数据传输，双方使用 Worker.postMessage() 来发送数据，Worker.onMessage() 来接收数据，传输的数据并不是直接共享，而是被复制的。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // game.json { &quot;workers&quot;: &quot;workers&quot; } // 创建worker线程 let worker = worker = wx.createWorker(&#39;workers/request/index.js&#39;) // 文件名指定 worker 的入口文件路径，绝对路径 // 主线程向 Worker 发送消息 worker.postMessage({ msg: &#39;hello worker&#39; }) // 主线程监听 Worker 返回消息 worker.onMessage(function (res) { console.log(res) }) 需要注意的是：Worker 最大并发数量限制为 1 个，创建下一个前请用 Worker.terminate() 结束当前 Worker 其他 Worker 相关的内容请参考微信官方文档：多线程 Worker 结语 短短的一篇文章，定不能将层叠拼图Plus小游戏的前前后后讲明白讲透彻，加上文笔有限，有描述不当的地方还望多多海涵。其实最让人心累的还是软著的申请过程，由于各种原因前前后后花了将近三个月的时间，本来也想写一下软著申请相关的内容，最后发现篇幅有点长，无奈作罢，争取后面花点时间整理一下我这边的经验，希望可以帮助到需要的童鞋。 由于项目结构以及代码还比较混乱，个人觉得，目前暂时还不适合开源。好在，小游戏内的所有核心代码以及游戏实现思想均已呈上，有兴趣的同学如果有相关方面的疑问也可以与我多多交流，大家互相学习，共同进步。 体验游戏： 江湖不远，我们游戏里见！" /><link rel="canonical" href="https://kokohuang.github.io/posts/weapp-game-stack/" /><meta property="og:url" content="https://kokohuang.github.io/posts/weapp-game-stack/" /><meta property="og:site_name" content="kokohuang’s blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-09-12T12:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="烧脑！JS+Canvas带你体验「偶消奇不消」的智商挑战" /><meta name="twitter:site" content="@jianke00" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"mainEntityOfPage":{"@type":"WebPage","@id":"https://kokohuang.github.io/posts/weapp-game-stack/"},"datePublished":"2019-09-12T12:00:00+08:00","description":"启逻辑之高妙，因想象而自由 层叠拼图Plus是一款需要空间想象力和逻辑推理能力完美结合的微信小游戏，偶消奇不消，在简单的游戏规则下却有着无数种可能性，需要你充分发挥想象力去探索，看似简单却具有极大的挑战性和趣味性，这就是其魅力所在！ 游戏界面预览： Talk is cheap. Show me the code 层叠拼图Plus微信小游戏采用js+canvas实现，没有使用任何游戏引擎，对于初学者来说，也比较容易入门。接下来，我将通过以下几个点循序渐进的讲解层叠拼图Plus微信小游戏的实现。 如何解决Canvas绘图模糊？ 如何绘制任意多边形图形？ 1 + 1 = 0，「偶消奇不消」的效果如何实现？ 如何判断一个点是否在任意多边形内部 ？ 如何判断游戏结果是否正确？ 排行榜的展示 游戏性能优化 如何解决Canvas绘图模糊？ canvas 绘图时，会从两个物理像素的中间位置开始绘制并向两边扩散 0.5 个物理像素。当设备像素比为 1 时，一个 1px 的线条实际上占据了两个物理像素（每个像素实际上只占一半），由于不存在 0.5 个像素，所以这两个像素本来不应该被绘制的部分也被绘制了，于是 1 物理像素的线条变成了 2 物理像素，视觉上就造成了模糊 绘图模糊的原因知道了，在微信小游戏里面又该如何解决呢？ 1 2 3 4 5 6 7 8 9 10 11 const ratio = wx.getSystemInfoSync().pixelRatio let ctx = canvas.getContext(&#39;2d&#39;) canvas.width = screenWidth * ratio canvas.height = screenHeight * ratio ctx.fillStyle = &#39;black&#39; ctx.font = `${18 * ratio}px Arial` ctx.fillText(&#39;我是清晰的文字&#39;, x * ratio, y * ratio) ctx.fillStyle = &#39;red&#39; ctx.fillRect(x * ratio, y * ratio, width * ratio, height * ratio) 可以看到，我们先通过 wx.getSystemInfoSync().pixelRatio 获取设备的像素比ratio，然后将在屏 Canvas 的宽度和高度按照所获取的像素比ratio进行放大，在绘制文字、图片的时候，坐标点 x、y 和所要绘制图形的 width、height均需要按照像素比 ratio 进行缩放，这样我们就可以清晰的在高清屏中绘制想要的文字、图片。 可参考微信官方 缩放策略调整 另外，需要注意的是，这里的 canvas 是由 weapp-adapter 预先调用 wx.createCanvas() 创建一个上屏 Canvas，并暴露为一个全局变量 canvas。 如何绘制任意多边形图形？ 任意一个多边形图形，是由多个平面坐标点所组成的图形区域。 在游戏画布内，我们以左上角为坐标原点 {x: 0, y: 0} ，一个多边形包含多个单位长度的平面坐标点，如：[{ x: 1, y: 3 }, { x: 5, y: 3 }, { x: 3, y: 5 }] 表示为一个三角形的区域，需要注意的是，x、y 并不是真实的平面坐标值，而是通过屏幕宽度计算出来的单位长度，在画布内的真实坐标值则为 {x: x * itemWidth, y: y * itemWidth} 。 绘制多边形代码实现如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /** * 绘制多边形 */ export default class Block { constructor() { } init(points, itemWidth, ctx) { this.points = [] this.itemWidth = itemWidth // 单位长度 this.ctx = ctx for (let i = 0; i &lt; points.length; i++) { let point = points[i] this.points.push({ x: point.x * this.itemWidth, y: point.y * this.itemWidth }) } } draw() { this.ctx.globalCompositeOperation = &#39;xor&#39; this.ctx.fillStyle = &#39;black&#39; this.ctx.beginPath() this.ctx.moveTo(this.points[0].x, this.points[0].y) for (let i = 1; i &lt; this.points.length; i++) { let point = this.points[i] this.ctx.lineTo(point.x, point.y) } this.ctx.closePath() this.ctx.fill() } } 使用： 1 2 3 4 5 6 7 8 9 10 let points = [ [{ x: 4, y: 5 }, { x: 8, y: 9 }, { x: 4, y: 9 }], [{ x: 10, y: 8 }, { x: 10, y: 12 }, { x: 6, y: 12 }], [{ x: 7, y: 4 }, { x: 11, y: 4 }, { x: 11, y: 8 }] ] points.map((sub_points) =&gt; { let block = new Block() block.init(sub_points, this.itemWidth, this.ctx) block.draw() }) 效果如下图： CanvasRenderingContext2D其他使用方法可参考：CanvasRenderingContext2D API 列表 1 + 1 = 0，「偶消奇不消」的效果如何实现？ 1 + 1 = 0，是层叠拼图Plus小游戏玩法的精髓所在。 有经验的同学，也许一眼就发现了，1 + 1 = 0 刚好符合通过 异或运算 得出的结果。当然，细心的同学也可能已经发现，在 如何绘制任意多边形图形 这一章节内，有一句特殊的代码：this.ctx.globalCompositeOperation = &#39;xor&#39;，也正是通过设置 CanvasContext 的 globalCompositeOperation 属性值为 xor 便实现了「偶消奇不消」的神奇效果。 globalCompositeOperation 是指 在绘制新形状时应用的合成操作的类型，其他效果可参考：globalCompositeOperation 示例 如何判断一个点是否在任意多边形内部？ 当回转数为 0 时，点在闭合曲线外部。 讲到这里，我们已经知道如何在Canvas画布内绘制出偶消奇不消效果的层叠图形了，接下来我们来看下玩家如何移动选中的图形。我们发现绘制出的图形对象并没有提供点击事件绑定之类的操作，那又如何判断玩家选中了哪个图形呢？这里我们就需要去实现如何判断玩家触摸事件的x，y坐标在哪个多边形图形内部区域，从而判断出玩家选中的是哪一个多边形图形。 判断一个点是否在任意多边形内部有多种方法，比如： 射线法 面积判别法 叉乘判别法 回转数法 … 在层叠拼图Plus小游戏内，采用的是 回转数 法来判断玩家触摸点是否在多边形内部。回转数 是拓扑学中的一个基本概念，具有很重要的性质和用途。当然，展开讨论 回转数 的概念并不在该文的讨论范围内，我们仅需了解一个概念：当回转数为 0 时，点在闭合曲线外部。 上面面这张图动态演示了回转数的概念：图中红色曲线关于点（人所在位置）的回转数为 2。 对于给定的点和多边形，回转数应该怎么计算呢？ 用线段分别连接点和多边形的全部顶点 计算所有点与相邻顶点连线的夹角 计算所有夹角和。注意每个夹角都是有方向的，所以有可能是负值 最后根据角度累加值计算回转数。360°（2π）相当于一次回转。 在使用 JavaScript 实现时，需要注意以下问题： JavaScript 的数只有 64 位双精度浮点这一种。对于三角函数产生的无理数，浮点数计算不可避免会造成一些误差，因此在最后计算回转数需要做取整操作。 通常情况下，平面直角坐标系内一个角的取值范围是 -π 到 π 这个区间，这也是 JavaScript 三角函数 Math.atan2() 返回值的范围。但 JavaScript 并不能直接计算任意两条线的夹角，我们只能先计算两条线与 x 正轴夹角，再取两者差值。这个差值的结果就有可能超出 -π 到 π 这个区间，因此我们还需要处理差值超出取值区间的情况。 代码实现： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /** * 判断点是否在多边形内/边上 */ isPointInPolygon(p, poly) { let px = p.x, py = p.y, sum = 0 for (let i = 0, l = poly.length, j = l - 1; i &lt; l; j = i, i++) { let sx = poly[i].x, sy = poly[i].y, tx = poly[j].x, ty = poly[j].y // 点与多边形顶点重合或在多边形的边上 if ((sx - px) * (px - tx) &gt;= 0 &amp;&amp; (sy - py) * (py - ty) &gt;= 0 &amp;&amp; (px - sx) * (ty - sy) === (py - sy) * (tx - sx)) { return true } // 点与相邻顶点连线的夹角 let angle = Math.atan2(sy - py, sx - px) - Math.atan2(ty - py, tx - px) // 确保夹角不超出取值范围（-π 到 π） if (angle &gt;= Math.PI) { angle = angle - Math.PI * 2 } else if (angle &lt;= -Math.PI) { angle = angle + Math.PI * 2 } sum += angle } // 计算回转数并判断点和多边形的几何关系 return Math.round(sum / Math.PI) === 0 ? false : true } 注：该章节内容图片均来自网络，如有侵权，请告知删除。另外有兴趣的同学可以使用其他方法来实现判断一个点是否在任意多边形内部。 如何判断游戏结果是否正确？ 探索的过程固然精彩，而结果却更令我们期待 通过前面的介绍我们可以知道，判断游戏结果是否正确其实就是比对玩家组合图形的 xor 结果与目标图形的 xor 结果。那么如何求多个多边形 xor 的结果呢？ polygon-clipping 正是为此而生的。它不仅支持 xor 操作，还有其他的比如：union, intersection, difference 等操作。 在层叠拼图Plus游戏内通过 polygon-clipping 又是怎样实现游戏结果判断的呢？ 目标图形 多边形平面坐标点集合： 1 2 3 4 points = [ [{ x: 6, y: 6 }, { x: 10, y: 6 }, { x: 10, y: 10 }, { x: 6, y: 10 }], [{ x: 8, y: 6 }, { x: 10, y: 8 }, { x: 8, y: 10 }, { x: 6, y: 8 }] ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /** * 获取 多个多边形 xor 结果 */ const polygonClipping = require(&#39;polygon-clipping&#39;) polygonXor(points) { let poly = [] points.forEach(function (sub_points) { let temp = [] sub_points.forEach(function (point) { temp.push([point.x, point.y]) }) poly.push([temp]) }) let results = polygonClipping.xor(...poly) // 找出左上角的点 let min_x = 100, min_y = 100 results.forEach(function (sub_results) { sub_results.forEach(function (temps) { temps.forEach(function (point) { if (point[0] &lt; min_x) min_x = point[0] if (point[1] &lt; min_y) min_y = point[1] }) }) }) // 以左上角为参考点 多边形平移至 原点 {x: 0, y: 0} results.forEach(function (sub_results) { sub_results.forEach(function (temps) { temps.forEach(function (point) { point[0] -= min_x point[1] -= min_y }) }) }) } xor结果： 1 2 3 4 5 6 7 let result = this.polygonXor(points) result = [ [[[0, 0], [2, 0], [0, 2], [0, 0]]], [[[0, 2], [2, 4], [0, 4], [0, 2]]], [[[2, 0], [4, 0], [4, 2], [2, 0]]], [[[2, 4], [4, 2], [4, 4], [2, 4]]] ] 同理计算出玩家操作图形的xor结果进行比对即可得出答案正确与否。 需要注意的是，获取玩家的 xor 结果并不能直接拿来与目标图形xor 结果进行比较，我们需要将xor 的结果以左上角为参考点将图形平移至原点内，然后再进行比较，如果结果一致，则代表玩家答案正确。 排行榜的展示 有人的地方就有江湖，有江湖的地方就有排行 在看本章节内容之前，建议先浏览一遍排行榜相关的官方文档：好友排行榜、关系链数据，以便对相关内容有个大概的了解。 开放数据域 开放数据域是一个封闭、独立的 JavaScript 作用域。要让代码运行在开放数据域，需要在 game.json 中添加配置项 openDataContext 指定开放数据域的代码目录。添加该配置项表示小游戏启用了开放数据域，这将会导致一些限制。 1 2 3 4 // game.json { &quot;openDataContext&quot;: &quot;src/myOpenDataContext&quot; } 在游戏内使用 wx.setUserCloudStorage(obj) 对玩家游戏数据进行托管。 在开放数据域内使用 wx.getFriendCloudStorage(obj)拉取当前用户所有同玩好友的托管数据 展示关系链数据 如果想要展示通过关系链 API 获取到的用户数据，如绘制排行榜等业务场景，需要将排行榜绘制到 sharedCanvas 上，再在主域将 sharedCanvas 渲染上屏。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/myOpenDataContext/index.js let sharedCanvas = wx.getSharedCanvas() function drawRankList (data) { data.forEach((item, index) =&gt; { // ... }) } wx.getFriendCloudStorage({ success: res =&gt; { let data = res.data drawRankList(data) } }) sharedCanvas 是主域和开放数据域都可以访问的一个离屏画布。在开放数据域调用 wx.getSharedCanvas() 将返回 sharedCanvas。 1 2 3 4 5 // src/myOpenDataContext/index.js let sharedCanvas = wx.getSharedCanvas() let context = sharedCanvas.getContext(&#39;2d&#39;) context.fillStyle = &#39;red&#39; context.fillRect(0, 0, 100, 100) 在主域中可以通过开放数据域实例访问 sharedCanvas，通过 drawImage() 方法可以将 sharedCanvas 绘制到上屏画布。 1 2 3 4 5 6 7 // game.js let openDataContext = wx.getOpenDataContext() let sharedCanvas = openDataContext.canvas let canvas = wx.createCanvas() let context = canvas.getContext(&#39;2d&#39;) context.drawImage(sharedCanvas, 0, 0) sharedCanvas 本质上也是一个离屏 Canvas，而重设 Canvas 的宽高会清空 Canvas 上的内容。所以要通知开放数据域去重绘 sharedCanvas。 1 2 3 4 5 6 7 8 9 10 11 // game.js openDataContext.postMessage({ command: &#39;render&#39; }) // src/myOpenDataContext/index.js openDataContext.onMessage(data =&gt; { if (data.command === &#39;render&#39;) { // 重绘 sharedCanvas } }) 需要注意的是：sharedCanvas 的宽高只能在主域设置，不能在开放数据域中设置。 游戏性能优化 性能优化，简而言之，就是在不影响系统运行正确性的前提下，使之运行地更快，完成特定功能所需的时间更短。 一款能让人心情愉悦的游戏，性能问题必然不能成为绊脚石。那么可以从哪些方面对游戏进行性能优化呢？ 离屏 Canvas 在层叠拼图Plus小游戏内，针对需要大量使用且绘图繁复的静态场景，都是使用离屏 Canvas进行绘制的，如首页网格背景、关卡列表、排名列表等。在微信内 wx.createCanvas() 首次调用创建的是显示在屏幕上的画布，之后调用创建的都是离屏画布。初始化时将静态场景绘制完备，需要时直接拷贝离屏Canvas的图像即可。Canvas 绘制本身就是不断的更新帧从而达到动画的效果，通过使用离屏 Canvas，就大大减少了一些静态内容在上屏Canvas的绘制，从而提升了绘制性能。 1 2 3 4 5 this.offScreenCanvas = wx.createCanvas() this.offScreenCanvas.width = this.width * ratio this.offScreenCanvas.height = this.height * ratio this.ctx.drawImage(this.offScreenCanvas, x * ratio, y * ratio, this.offScreenCanvas.width, this.offScreenCanvas.height) 内存优化 玩家在游戏过程中拖动方块的移动其实就是不断更新多边形图形的坐标信息，然后不断的清空画布再重新绘制，可以想象，这个绘制是非常频繁的，按照普通的做法就需要不断去创建多个新的 Block 对象。针对游戏中需要频繁更新的对象，我们可以通过使用对象池的方法进行优化，对象池维护一个装着空闲对象的池子，如果需要对象的时候，不是直接new，而是从对象池中取出，如果对象池中没有空闲对象，则新建一个空闲对象，层叠拼图Plus小游戏内使用的是官方demo内已经实现的对象池类，实现如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 const __ = { poolDic: Symbol(&#39;poolDic&#39;) } /** * 简易的对象池实现 * 用于对象的存贮和重复使用 * 可以有效减少对象创建开销和避免频繁的垃圾回收 * 提高游戏性能 */ export default class Pool { constructor() { this[__.poolDic] = {} } /** * 根据对象标识符 * 获取对应的对象池 */ getPoolBySign(name) { return this[__.poolDic][name] || ( this[__.poolDic][name] = [] ) } /** * 根据传入的对象标识符，查询对象池 * 对象池为空创建新的类，否则从对象池中取 */ getItemByClass(name, className) { let pool = this.getPoolBySign(name) let result = ( pool.length ? pool.shift() : new className() ) return result } /** * 将对象回收到对象池 * 方便后续继续使用 */ recover(name, instance) { this.getPoolBySign(name).push(instance) } } 垃圾回收 小游戏中，JavaScript 中的每一个 Canvas 或 Image 对象都会有一个客户端层的实际纹理储存，实际纹理储存中存放着 Canvas、Image 的真实纹理，通常会占用相当一部分内存。 每个客户端实际纹理储存的回收时机依赖于 JavaScript 中的 Canvas、Image 对象回收。在 JavaScript 的 Canvas、Image 对象被回收之前，客户端对应的实际纹理储存不会被回收。通过调用 wx.triggerGC() 方法，可以加快触发 JavaScriptCore Garbage Collection（垃圾回收），从而触发 JavaScript 中没有引用的 Canvas、Image 回收，释放对应的实际纹理储存。 但 GC 具体触发时机还要取决于 JavaScriptCore 自身机制，并不能保证调用 wx.triggerGC() 能马上触发回收，层叠拼图Plus小游戏在每局游戏开始或结束都会触发一下，及时回收内存垃圾，以保证最良好的游戏体验。 多线程 Worker 对于游戏来说，每帧 16ms 是极其宝贵的，如果有一些可以异步处理的任务，可以放置于 Worker 中运行，待运行结束后，再把结果返回到主线程。Worker 运行于一个单独的全局上下文与线程中，不能直接调用主线程的方法，Worker 也不具备渲染的能力。 Worker与主线程之间的数据传输，双方使用 Worker.postMessage() 来发送数据，Worker.onMessage() 来接收数据，传输的数据并不是直接共享，而是被复制的。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // game.json { &quot;workers&quot;: &quot;workers&quot; } // 创建worker线程 let worker = worker = wx.createWorker(&#39;workers/request/index.js&#39;) // 文件名指定 worker 的入口文件路径，绝对路径 // 主线程向 Worker 发送消息 worker.postMessage({ msg: &#39;hello worker&#39; }) // 主线程监听 Worker 返回消息 worker.onMessage(function (res) { console.log(res) }) 需要注意的是：Worker 最大并发数量限制为 1 个，创建下一个前请用 Worker.terminate() 结束当前 Worker 其他 Worker 相关的内容请参考微信官方文档：多线程 Worker 结语 短短的一篇文章，定不能将层叠拼图Plus小游戏的前前后后讲明白讲透彻，加上文笔有限，有描述不当的地方还望多多海涵。其实最让人心累的还是软著的申请过程，由于各种原因前前后后花了将近三个月的时间，本来也想写一下软著申请相关的内容，最后发现篇幅有点长，无奈作罢，争取后面花点时间整理一下我这边的经验，希望可以帮助到需要的童鞋。 由于项目结构以及代码还比较混乱，个人觉得，目前暂时还不适合开源。好在，小游戏内的所有核心代码以及游戏实现思想均已呈上，有兴趣的同学如果有相关方面的疑问也可以与我多多交流，大家互相学习，共同进步。 体验游戏： 江湖不远，我们游戏里见！","@type":"BlogPosting","url":"https://kokohuang.github.io/posts/weapp-game-stack/","headline":"烧脑！JS+Canvas带你体验「偶消奇不消」的智商挑战","dateModified":"2021-04-02T16:52:55+08:00","@context":"https://schema.org"}</script><title>烧脑！JS+Canvas带你体验「偶消奇不消」的智商挑战 | kokohuang's blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/images/avatar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">kokohuang's blog</a></div><div class="site-subtitle font-italic">不忘初心，方得始终</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/kokohuang" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/jianke00" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['huangjianke','vip.163.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> 文章 </a> </span> <span>烧脑！JS+Canvas带你体验「偶消奇不消」的智商挑战</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="搜索..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>烧脑！JS+Canvas带你体验「偶消奇不消」的智商挑战</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> kokohuang </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="2019年09月12日" prep="on" > 2019年09月12日 <i class="unloaded">2019-09-12T12:00:00+08:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="2021年04月02日" prefix="Updated " > 04月02日 <i class="unloaded">2021-04-02T16:52:55+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="5048 words">28 分钟</span></div></div><div class="post-content"><meta name="referrer" content="no-referrer" /><blockquote><p>启逻辑之高妙，因想象而自由</p></blockquote><p><strong>层叠拼图Plus</strong>是一款需要空间想象力和逻辑推理能力完美结合的微信小游戏，偶消奇不消，在简单的游戏规则下却有着无数种可能性，需要你充分发挥想象力去探索，看似简单却具有极大的挑战性和趣味性，这就是其魅力所在！</p><p>游戏界面预览：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-gold-cdn.xitu.io/2019/9/6/16d0494a8829d90c?w=500&amp;h=541&amp;f=png&amp;s=94442" alt="preview" /></p><blockquote><p>Talk is cheap. Show me the code</p></blockquote><p><strong>层叠拼图Plus</strong>微信小游戏采用<code class="language-plaintext highlighter-rouge">js</code>+<code class="language-plaintext highlighter-rouge">canvas</code>实现，没有使用任何游戏引擎，对于初学者来说，也比较容易入门。接下来，我将通过以下几个点循序渐进的讲解<strong>层叠拼图Plus</strong>微信小游戏的实现。</p><ul><li><strong>如何解决Canvas绘图模糊？</strong><li><strong>如何绘制任意多边形图形？</strong><li><strong>1 + 1 = 0，「偶消奇不消」的效果如何实现？</strong><li><strong>如何判断一个点是否在任意多边形内部 ？</strong><li><strong>如何判断游戏结果是否正确？</strong><li><strong>排行榜的展示</strong><li><strong>游戏性能优化</strong></ul><h2 id="如何解决canvas绘图模糊">如何解决Canvas绘图模糊？</h2><blockquote><p>canvas 绘图时，会从两个物理像素的中间位置开始绘制并向两边扩散 0.5 个物理像素。当设备像素比为 1 时，一个 1px 的线条实际上占据了两个物理像素（每个像素实际上只占一半），由于不存在 0.5 个像素，所以这两个像素本来不应该被绘制的部分也被绘制了，于是 1 物理像素的线条变成了 2 物理像素，视觉上就造成了模糊</p></blockquote><p>绘图模糊的原因知道了，在微信小游戏里面又该如何解决呢？</p><div class="language-javascript highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">ratio</span> <span class="o">=</span> <span class="nx">wx</span><span class="p">.</span><span class="nx">getSystemInfoSync</span><span class="p">().</span><span class="nx">pixelRatio</span>
<span class="kd">let</span> <span class="nx">ctx</span> <span class="o">=</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">getContext</span><span class="p">(</span><span class="dl">'</span><span class="s1">2d</span><span class="dl">'</span><span class="p">)</span>
<span class="nx">canvas</span><span class="p">.</span><span class="nx">width</span> <span class="o">=</span> <span class="nx">screenWidth</span> <span class="o">*</span> <span class="nx">ratio</span>
<span class="nx">canvas</span><span class="p">.</span><span class="nx">height</span> <span class="o">=</span> <span class="nx">screenHeight</span> <span class="o">*</span> <span class="nx">ratio</span>

<span class="nx">ctx</span><span class="p">.</span><span class="nx">fillStyle</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">black</span><span class="dl">'</span>
<span class="nx">ctx</span><span class="p">.</span><span class="nx">font</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="mi">18</span> <span class="o">*</span> <span class="nx">ratio</span><span class="p">}</span><span class="s2">px Arial`</span>
<span class="nx">ctx</span><span class="p">.</span><span class="nx">fillText</span><span class="p">(</span><span class="dl">'</span><span class="s1">我是清晰的文字</span><span class="dl">'</span><span class="p">,</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">ratio</span><span class="p">,</span> <span class="nx">y</span> <span class="o">*</span> <span class="nx">ratio</span><span class="p">)</span>

<span class="nx">ctx</span><span class="p">.</span><span class="nx">fillStyle</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">red</span><span class="dl">'</span>
<span class="nx">ctx</span><span class="p">.</span><span class="nx">fillRect</span><span class="p">(</span><span class="nx">x</span> <span class="o">*</span> <span class="nx">ratio</span><span class="p">,</span> <span class="nx">y</span> <span class="o">*</span> <span class="nx">ratio</span><span class="p">,</span> <span class="nx">width</span> <span class="o">*</span> <span class="nx">ratio</span><span class="p">,</span> <span class="nx">height</span> <span class="o">*</span> <span class="nx">ratio</span><span class="p">)</span>
</pre></table></code></div></div><p>可以看到，我们先通过 <code class="language-plaintext highlighter-rouge">wx.getSystemInfoSync().pixelRatio</code> 获取设备的像素比<code class="language-plaintext highlighter-rouge">ratio</code>，然后将在屏 <code class="language-plaintext highlighter-rouge">Canvas</code> 的宽度和高度按照所获取的像素比<code class="language-plaintext highlighter-rouge">ratio</code>进行放大，在绘制文字、图片的时候，坐标点 <code class="language-plaintext highlighter-rouge">x</code>、<code class="language-plaintext highlighter-rouge">y</code> 和所要绘制图形的 <code class="language-plaintext highlighter-rouge">width</code>、<code class="language-plaintext highlighter-rouge">height</code>均需要按照像素比 <code class="language-plaintext highlighter-rouge">ratio</code> 进行缩放，这样我们就可以清晰的在高清屏中绘制想要的文字、图片。</p><p>可参考微信官方 <a href="https://developers.weixin.qq.com/community/develop/doc/00040c9903023848e0d7bd6205a401?highLine=canvas%2520%25E6%25A8%25A1%25E7%25B3%258A">缩放策略调整</a></p><p><strong><em>另外，需要注意的是，这里的 <code class="language-plaintext highlighter-rouge">canvas</code> 是由 <a href="https://developers.weixin.qq.com/minigame/dev/guide/best-practice/adapter.html">weapp-adapter</a> 预先调用 <code class="language-plaintext highlighter-rouge">wx.createCanvas()</code> 创建一个上屏 <code class="language-plaintext highlighter-rouge">Canvas</code>，并暴露为一个全局变量 <code class="language-plaintext highlighter-rouge">canvas</code>。</em></strong></p><h2 id="如何绘制任意多边形图形">如何绘制任意多边形图形？</h2><blockquote><p>任意一个多边形图形，是由多个平面坐标点所组成的图形区域。</p></blockquote><p>在游戏画布内，我们以左上角为坐标原点 <code class="language-plaintext highlighter-rouge">{x: 0, y: 0}</code> ，一个多边形包含多个单位长度的平面坐标点，如：<code class="language-plaintext highlighter-rouge">[{ x: 1, y: 3 }, { x: 5, y: 3 }, { x: 3, y: 5 }]</code> 表示为一个三角形的区域，需要注意的是，<code class="language-plaintext highlighter-rouge">x</code>、<code class="language-plaintext highlighter-rouge">y</code> 并不是真实的平面坐标值，而是通过屏幕宽度计算出来的单位长度，在画布内的真实坐标值则为 <code class="language-plaintext highlighter-rouge">{x: x * itemWidth, y: y * itemWidth}</code> 。</p><p>绘制多边形代码实现如下：</p><div class="language-javascript highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="cm">/**
 * 绘制多边形
 */</span>
<span class="k">export</span> <span class="k">default</span> <span class="kd">class</span> <span class="nx">Block</span> <span class="p">{</span>
    <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
    <span class="nx">init</span><span class="p">(</span><span class="nx">points</span><span class="p">,</span> <span class="nx">itemWidth</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">itemWidth</span> <span class="o">=</span> <span class="nx">itemWidth</span> <span class="c1">// 单位长度</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">ctx</span> <span class="o">=</span> <span class="nx">ctx</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">points</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="nx">point</span> <span class="o">=</span> <span class="nx">points</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">points</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
                <span class="na">x</span><span class="p">:</span> <span class="nx">point</span><span class="p">.</span><span class="nx">x</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">itemWidth</span><span class="p">,</span>
                <span class="na">y</span><span class="p">:</span> <span class="nx">point</span><span class="p">.</span><span class="nx">y</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">itemWidth</span>
            <span class="p">})</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">draw</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">ctx</span><span class="p">.</span><span class="nx">globalCompositeOperation</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">xor</span><span class="dl">'</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">ctx</span><span class="p">.</span><span class="nx">fillStyle</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">black</span><span class="dl">'</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">ctx</span><span class="p">.</span><span class="nx">beginPath</span><span class="p">()</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">ctx</span><span class="p">.</span><span class="nx">moveTo</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">points</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">x</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">points</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">y</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">points</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="nx">point</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">points</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">ctx</span><span class="p">.</span><span class="nx">lineTo</span><span class="p">(</span><span class="nx">point</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">point</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">ctx</span><span class="p">.</span><span class="nx">closePath</span><span class="p">()</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">ctx</span><span class="p">.</span><span class="nx">fill</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>使用：</p><div class="language-javascript highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">let</span> <span class="nx">points</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">5</span> <span class="p">},</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">9</span> <span class="p">},</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">9</span> <span class="p">}],</span>
    <span class="p">[{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">8</span> <span class="p">},</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">12</span> <span class="p">},</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">12</span> <span class="p">}],</span>
    <span class="p">[{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">4</span> <span class="p">},</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">4</span> <span class="p">},</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">8</span> <span class="p">}]</span>
<span class="p">]</span>
<span class="nx">points</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">sub_points</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">block</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Block</span><span class="p">()</span>
    <span class="nx">block</span><span class="p">.</span><span class="nx">init</span><span class="p">(</span><span class="nx">sub_points</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">itemWidth</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">ctx</span><span class="p">)</span>
    <span class="nx">block</span><span class="p">.</span><span class="nx">draw</span><span class="p">()</span>
<span class="p">})</span>
</pre></table></code></div></div><p>效果如下图：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-gold-cdn.xitu.io/2019/8/26/16ccb963282cbf04?w=300&amp;h=301&amp;f=png&amp;s=53047" alt="block" /></p><p><code class="language-plaintext highlighter-rouge">CanvasRenderingContext2D</code>其他使用方法可参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D">CanvasRenderingContext2D API 列表</a></p><h2 id="1--1--0偶消奇不消的效果如何实现">1 + 1 = 0，「偶消奇不消」的效果如何实现？</h2><blockquote><p>1 + 1 = 0，是<strong>层叠拼图Plus</strong>小游戏玩法的精髓所在。</p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-gold-cdn.xitu.io/2019/8/19/16ca96beb9a40d9f?w=300&amp;h=306&amp;f=png&amp;s=36811" alt="xor" /></p><p>有经验的同学，也许一眼就发现了，<code class="language-plaintext highlighter-rouge">1 + 1 = 0</code> 刚好符合通过 <code class="language-plaintext highlighter-rouge">异或运算</code> 得出的结果。当然，细心的同学也可能已经发现，在 <code class="language-plaintext highlighter-rouge">如何绘制任意多边形图形</code> 这一章节内，有一句特殊的代码：<code class="language-plaintext highlighter-rouge">this.ctx.globalCompositeOperation = 'xor'</code>，也正是通过设置 <code class="language-plaintext highlighter-rouge">CanvasContext</code> 的 <code class="language-plaintext highlighter-rouge">globalCompositeOperation</code> 属性值为 <code class="language-plaintext highlighter-rouge">xor</code> 便实现了「偶消奇不消」的神奇效果。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-gold-cdn.xitu.io/2019/8/19/16ca94dcda5b68f8?w=1526&amp;h=522&amp;f=png&amp;s=115558" alt="globalCompositeOperation" /></p><p><code class="language-plaintext highlighter-rouge">globalCompositeOperation</code> 是指 <code class="language-plaintext highlighter-rouge">在绘制新形状时应用的合成操作的类型</code>，其他效果可参考：<a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation">globalCompositeOperation 示例</a></p><h2 id="如何判断一个点是否在任意多边形内部">如何判断一个点是否在任意多边形内部？</h2><blockquote><p>当回转数为 0 时，点在闭合曲线外部。</p></blockquote><p>讲到这里，我们已经知道如何在<code class="language-plaintext highlighter-rouge">Canvas</code>画布内绘制出偶消奇不消效果的层叠图形了，接下来我们来看下玩家如何移动选中的图形。我们发现绘制出的图形对象并没有提供点击事件绑定之类的操作，那又如何判断玩家选中了哪个图形呢？这里我们就需要去实现如何判断玩家触摸事件的<code class="language-plaintext highlighter-rouge">x</code>，<code class="language-plaintext highlighter-rouge">y</code>坐标在哪个多边形图形内部区域，从而判断出玩家选中的是哪一个多边形图形。</p><p>判断一个点是否在任意多边形内部有多种方法，比如：</p><ul><li>射线法<li>面积判别法<li>叉乘判别法<li>回转数法<li>…</ul><p>在<strong>层叠拼图Plus</strong>小游戏内，采用的是 <code class="language-plaintext highlighter-rouge">回转数</code> 法来判断玩家触摸点是否在多边形内部。<code class="language-plaintext highlighter-rouge">回转数</code> 是拓扑学中的一个基本概念，具有很重要的性质和用途。当然，展开讨论 <code class="language-plaintext highlighter-rouge">回转数</code> 的概念并不在该文的讨论范围内，我们仅需了解一个概念：<strong>当回转数为 0 时，点在闭合曲线外部。</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-gold-cdn.xitu.io/2019/8/19/16ca95f23b785c58?w=300&amp;h=244&amp;f=gif&amp;s=252242" alt="round" /></p><p>上面面这张图动态演示了回转数的概念：图中红色曲线关于点（人所在位置）的回转数为 <code class="language-plaintext highlighter-rouge">2</code>。</p><p>对于给定的点和多边形，回转数应该怎么计算呢？</p><ul><li>用线段分别连接点和多边形的全部顶点</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-gold-cdn.xitu.io/2019/8/19/16ca96251c22a09b?w=500&amp;h=360&amp;f=png&amp;s=27778" alt="all" /></p><ul><li>计算所有点与相邻顶点连线的夹角</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-gold-cdn.xitu.io/2019/8/19/16ca9627a8a9c710?w=500&amp;h=360&amp;f=png&amp;s=33046" alt="line" /></p><ul><li>计算所有夹角和。注意每个夹角都是有方向的，所以有可能是负值</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-gold-cdn.xitu.io/2019/8/19/16ca962d5d1f2d07?w=500&amp;h=360&amp;f=png&amp;s=35608" alt="sub" /></p><p>最后根据角度累加值计算回转数。360°（2π）相当于一次回转。</p><p>在使用 <code class="language-plaintext highlighter-rouge">JavaScript</code> 实现时，需要注意以下问题：</p><ul><li><code class="language-plaintext highlighter-rouge">JavaScript</code> 的数只有 <code class="language-plaintext highlighter-rouge">64</code> 位双精度浮点这一种。对于三角函数产生的无理数，浮点数计算不可避免会造成一些误差，因此在最后计算回转数需要做取整操作。<li>通常情况下，平面直角坐标系内一个角的取值范围是 -π 到 π 这个区间，这也是 <code class="language-plaintext highlighter-rouge">JavaScript</code> 三角函数 <code class="language-plaintext highlighter-rouge">Math.atan2()</code> 返回值的范围。但 <code class="language-plaintext highlighter-rouge">JavaScript</code> 并不能直接计算任意两条线的夹角，我们只能先计算两条线与 <code class="language-plaintext highlighter-rouge">x</code> 正轴夹角，再取两者差值。这个差值的结果就有可能超出 <code class="language-plaintext highlighter-rouge">-π</code> 到 <code class="language-plaintext highlighter-rouge">π</code> 这个区间，因此我们还需要处理差值超出取值区间的情况。</ul><p>代码实现：</p><div class="language-javascript highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="cm">/**
 * 判断点是否在多边形内/边上
 */</span>
<span class="nx">isPointInPolygon</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">poly</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">px</span> <span class="o">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span>
        <span class="nx">py</span> <span class="o">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span>
        <span class="nx">sum</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">l</span> <span class="o">=</span> <span class="nx">poly</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">l</span><span class="p">;</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">sx</span> <span class="o">=</span> <span class="nx">poly</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">x</span><span class="p">,</span>
            <span class="nx">sy</span> <span class="o">=</span> <span class="nx">poly</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">y</span><span class="p">,</span>
            <span class="nx">tx</span> <span class="o">=</span> <span class="nx">poly</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">x</span><span class="p">,</span>
            <span class="nx">ty</span> <span class="o">=</span> <span class="nx">poly</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">y</span>

        <span class="c1">// 点与多边形顶点重合或在多边形的边上</span>
        <span class="k">if</span> <span class="p">((</span><span class="nx">sx</span> <span class="o">-</span> <span class="nx">px</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nx">px</span> <span class="o">-</span> <span class="nx">tx</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
            <span class="p">(</span><span class="nx">sy</span> <span class="o">-</span> <span class="nx">py</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nx">py</span> <span class="o">-</span> <span class="nx">ty</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
            <span class="p">(</span><span class="nx">px</span> <span class="o">-</span> <span class="nx">sx</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nx">ty</span> <span class="o">-</span> <span class="nx">sy</span><span class="p">)</span> <span class="o">===</span> <span class="p">(</span><span class="nx">py</span> <span class="o">-</span> <span class="nx">sy</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nx">tx</span> <span class="o">-</span> <span class="nx">sx</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">true</span>
        <span class="p">}</span>

        <span class="c1">// 点与相邻顶点连线的夹角</span>
        <span class="kd">let</span> <span class="nx">angle</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">atan2</span><span class="p">(</span><span class="nx">sy</span> <span class="o">-</span> <span class="nx">py</span><span class="p">,</span> <span class="nx">sx</span> <span class="o">-</span> <span class="nx">px</span><span class="p">)</span> <span class="o">-</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">atan2</span><span class="p">(</span><span class="nx">ty</span> <span class="o">-</span> <span class="nx">py</span><span class="p">,</span> <span class="nx">tx</span> <span class="o">-</span> <span class="nx">px</span><span class="p">)</span>

        <span class="c1">// 确保夹角不超出取值范围（-π 到 π）</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">angle</span> <span class="o">&gt;=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">angle</span> <span class="o">=</span> <span class="nx">angle</span> <span class="o">-</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">angle</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">angle</span> <span class="o">=</span> <span class="nx">angle</span> <span class="o">+</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="p">}</span>
        <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">angle</span>
    <span class="p">}</span>

    <span class="c1">// 计算回转数并判断点和多边形的几何关系</span>
    <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">round</span><span class="p">(</span><span class="nx">sum</span> <span class="o">/</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span><span class="p">)</span> <span class="o">===</span> <span class="mi">0</span> <span class="p">?</span> <span class="kc">false</span> <span class="p">:</span> <span class="kc">true</span>
<span class="p">}</span>
</pre></table></code></div></div><p><em>注：该章节内容图片均来自网络，如有侵权，请告知删除。另外有兴趣的同学可以使用其他方法来实现判断一个点是否在任意多边形内部。</em></p><h2 id="如何判断游戏结果是否正确">如何判断游戏结果是否正确？</h2><blockquote><p>探索的过程固然精彩，而结果却更令我们期待</p></blockquote><p>通过前面的介绍我们可以知道，判断游戏结果是否正确其实就是比对玩家组合图形的 <code class="language-plaintext highlighter-rouge">xor</code> 结果与目标图形的 <code class="language-plaintext highlighter-rouge">xor</code> 结果。那么如何求多个多边形 <code class="language-plaintext highlighter-rouge">xor</code> 的结果呢？ <a href="https://github.com/mfogel/polygon-clipping">polygon-clipping</a> 正是为此而生的。它不仅支持 <code class="language-plaintext highlighter-rouge">xor</code> 操作，还有其他的比如：<code class="language-plaintext highlighter-rouge">union</code>, <code class="language-plaintext highlighter-rouge">intersection</code>, <code class="language-plaintext highlighter-rouge">difference</code> 等操作。 在<strong>层叠拼图Plus</strong>游戏内通过 <a href="https://github.com/mfogel/polygon-clipping">polygon-clipping</a> 又是怎样实现游戏结果判断的呢？</p><ul><li>目标图形</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-gold-cdn.xitu.io/2019/8/19/16ca99ee27b06341?w=300&amp;h=288&amp;f=png&amp;s=34253" alt="target" /></p><p>多边形平面坐标点集合：</p><div class="language-javascript highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nx">points</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">6</span> <span class="p">},</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">6</span> <span class="p">},</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">10</span> <span class="p">},</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">10</span> <span class="p">}],</span>
    <span class="p">[{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">6</span> <span class="p">},</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">8</span> <span class="p">},</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">10</span> <span class="p">},</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">8</span> <span class="p">}]</span>
<span class="p">]</span>
</pre></table></code></div></div><div class="language-javascript highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="cm">/**
 * 获取 多个多边形 xor 结果
 */</span>
<span class="kd">const</span> <span class="nx">polygonClipping</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">polygon-clipping</span><span class="dl">'</span><span class="p">)</span>

<span class="nx">polygonXor</span><span class="p">(</span><span class="nx">points</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">poly</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="nx">points</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">sub_points</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">temp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="nx">sub_points</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">point</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">temp</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="nx">point</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">point</span><span class="p">.</span><span class="nx">y</span><span class="p">])</span>
        <span class="p">})</span>
        <span class="nx">poly</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="nx">temp</span><span class="p">])</span>
    <span class="p">})</span>

    <span class="kd">let</span> <span class="nx">results</span> <span class="o">=</span> <span class="nx">polygonClipping</span><span class="p">.</span><span class="nx">xor</span><span class="p">(...</span><span class="nx">poly</span><span class="p">)</span>

    <span class="c1">// 找出左上角的点</span>
    <span class="kd">let</span> <span class="nx">min_x</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="nx">min_y</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="nx">results</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">sub_results</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">sub_results</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">temps</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">temps</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">point</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">min_x</span><span class="p">)</span> <span class="nx">min_x</span> <span class="o">=</span> <span class="nx">point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">min_y</span><span class="p">)</span> <span class="nx">min_y</span> <span class="o">=</span> <span class="nx">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">})</span>
        <span class="p">})</span>
    <span class="p">})</span>

    <span class="c1">// 以左上角为参考点 多边形平移至 原点 {x: 0, y: 0}</span>
    <span class="nx">results</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">sub_results</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">sub_results</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">temps</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">temps</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">point</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="nx">min_x</span>
                <span class="nx">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="nx">min_y</span>
            <span class="p">})</span>
        <span class="p">})</span>
    <span class="p">})</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">xor</code>结果：</p><div class="language-javascript highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">polygonXor</span><span class="p">(</span><span class="nx">points</span><span class="p">)</span>
<span class="nx">result</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]],</span>
    <span class="p">[[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]],</span>
    <span class="p">[[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]],</span>
    <span class="p">[[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]]</span>
<span class="p">]</span>
</pre></table></code></div></div><p>同理计算出玩家操作图形的<code class="language-plaintext highlighter-rouge">xor</code>结果进行比对即可得出答案正确与否。</p><p><strong><em>需要注意的是，获取玩家的 <code class="language-plaintext highlighter-rouge">xor</code> 结果并不能直接拿来与目标图形<code class="language-plaintext highlighter-rouge">xor</code> 结果进行比较，我们需要将<code class="language-plaintext highlighter-rouge">xor</code> 的结果以左上角为参考点将图形平移至原点内，然后再进行比较，如果结果一致，则代表玩家答案正确。</em></strong></p><h2 id="排行榜的展示">排行榜的展示</h2><blockquote><p>有人的地方就有江湖，有江湖的地方就有排行</p></blockquote><p>在看本章节内容之前，建议先浏览一遍排行榜相关的官方文档：<a href="https://developers.weixin.qq.com/minigame/dev/guide/open-ability/ranklist.html">好友排行榜</a>、<a href="https://developers.weixin.qq.com/minigame/dev/guide/open-ability/open-data.html">关系链数据</a>，以便对相关内容有个大概的了解。</p><ul><li>开放数据域</ul><p><code class="language-plaintext highlighter-rouge">开放数据域</code>是一个封闭、独立的 <code class="language-plaintext highlighter-rouge">JavaScript</code> 作用域。要让代码运行在开放数据域，需要在 <code class="language-plaintext highlighter-rouge">game.json</code> 中添加配置项 <code class="language-plaintext highlighter-rouge">openDataContext</code> 指定开放数据域的代码目录。添加该配置项表示小游戏启用了开放数据域，这将会导致一些限制。</p><div class="language-javascript highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c1">// game.json</span>
<span class="p">{</span>
  <span class="dl">"</span><span class="s2">openDataContext</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">src/myOpenDataContext</span><span class="dl">"</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li><p>在游戏内使用 <code class="language-plaintext highlighter-rouge">wx.setUserCloudStorage(obj)</code> 对玩家游戏数据进行托管。</p><li><p>在开放数据域内使用 <code class="language-plaintext highlighter-rouge">wx.getFriendCloudStorage(obj)</code>拉取当前用户所有同玩好友的托管数据</p><li><p>展示关系链数据</p></ul><p>如果想要展示通过关系链 <code class="language-plaintext highlighter-rouge">API</code> 获取到的用户数据，如绘制排行榜等业务场景，需要将排行榜绘制到 <code class="language-plaintext highlighter-rouge">sharedCanvas</code> 上，再在主域将 <code class="language-plaintext highlighter-rouge">sharedCanvas</code> 渲染上屏。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-gold-cdn.xitu.io/2019/8/20/16cad11323cccf61?w=620&amp;h=460&amp;f=png&amp;s=16321" alt="rank" /></p><div class="language-javascript highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="c1">// src/myOpenDataContext/index.js</span>
<span class="kd">let</span> <span class="nx">sharedCanvas</span> <span class="o">=</span> <span class="nx">wx</span><span class="p">.</span><span class="nx">getSharedCanvas</span><span class="p">()</span>

<span class="kd">function</span> <span class="nx">drawRankList</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">data</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">item</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">})</span>
<span class="p">}</span>

<span class="nx">wx</span><span class="p">.</span><span class="nx">getFriendCloudStorage</span><span class="p">({</span>
  <span class="na">success</span><span class="p">:</span> <span class="nx">res</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">data</span> <span class="o">=</span> <span class="nx">res</span><span class="p">.</span><span class="nx">data</span>
    <span class="nx">drawRankList</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">})</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">sharedCanvas</code> 是主域和开放数据域都可以访问的一个离屏画布。在开放数据域调用 <code class="language-plaintext highlighter-rouge">wx.getSharedCanvas()</code> 将返回 <code class="language-plaintext highlighter-rouge">sharedCanvas</code>。</p><div class="language-javascript highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">// src/myOpenDataContext/index.js</span>
<span class="kd">let</span> <span class="nx">sharedCanvas</span> <span class="o">=</span> <span class="nx">wx</span><span class="p">.</span><span class="nx">getSharedCanvas</span><span class="p">()</span>
<span class="kd">let</span> <span class="nx">context</span> <span class="o">=</span> <span class="nx">sharedCanvas</span><span class="p">.</span><span class="nx">getContext</span><span class="p">(</span><span class="dl">'</span><span class="s1">2d</span><span class="dl">'</span><span class="p">)</span>
<span class="nx">context</span><span class="p">.</span><span class="nx">fillStyle</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">red</span><span class="dl">'</span>
<span class="nx">context</span><span class="p">.</span><span class="nx">fillRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
</pre></table></code></div></div><p>在主域中可以通过开放数据域实例访问 <code class="language-plaintext highlighter-rouge">sharedCanvas</code>，通过 <code class="language-plaintext highlighter-rouge">drawImage()</code> 方法可以将 <code class="language-plaintext highlighter-rouge">sharedCanvas</code> 绘制到上屏画布。</p><div class="language-javascript highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c1">// game.js</span>
<span class="kd">let</span> <span class="nx">openDataContext</span> <span class="o">=</span> <span class="nx">wx</span><span class="p">.</span><span class="nx">getOpenDataContext</span><span class="p">()</span>
<span class="kd">let</span> <span class="nx">sharedCanvas</span> <span class="o">=</span> <span class="nx">openDataContext</span><span class="p">.</span><span class="nx">canvas</span>

<span class="kd">let</span> <span class="nx">canvas</span> <span class="o">=</span> <span class="nx">wx</span><span class="p">.</span><span class="nx">createCanvas</span><span class="p">()</span>
<span class="kd">let</span> <span class="nx">context</span> <span class="o">=</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">getContext</span><span class="p">(</span><span class="dl">'</span><span class="s1">2d</span><span class="dl">'</span><span class="p">)</span>
<span class="nx">context</span><span class="p">.</span><span class="nx">drawImage</span><span class="p">(</span><span class="nx">sharedCanvas</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">sharedCanvas</code> 本质上也是一个离屏 <code class="language-plaintext highlighter-rouge">Canvas</code>，而重设 <code class="language-plaintext highlighter-rouge">Canvas</code> 的宽高会清空 <code class="language-plaintext highlighter-rouge">Canvas</code> 上的内容。所以要通知开放数据域去重绘 <code class="language-plaintext highlighter-rouge">sharedCanvas</code>。</p><div class="language-javascript highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="c1">// game.js</span>
<span class="nx">openDataContext</span><span class="p">.</span><span class="nx">postMessage</span><span class="p">({</span>
  <span class="na">command</span><span class="p">:</span> <span class="dl">'</span><span class="s1">render</span><span class="dl">'</span>
<span class="p">})</span>

<span class="c1">// src/myOpenDataContext/index.js</span>
<span class="nx">openDataContext</span><span class="p">.</span><span class="nx">onMessage</span><span class="p">(</span><span class="nx">data</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">command</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">render</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 重绘 sharedCanvas</span>
  <span class="p">}</span>
<span class="p">})</span>
</pre></table></code></div></div><p><strong><em>需要注意的是：<code class="language-plaintext highlighter-rouge">sharedCanvas</code> 的宽高只能在主域设置，不能在开放数据域中设置。</em></strong></p><h2 id="游戏性能优化">游戏性能优化</h2><blockquote><p>性能优化，简而言之，就是在不影响系统运行正确性的前提下，使之运行地更快，完成特定功能所需的时间更短。</p></blockquote><p>一款能让人心情愉悦的游戏，性能问题必然不能成为绊脚石。那么可以从哪些方面对游戏进行性能优化呢？</p><h3 id="离屏-canvas">离屏 <code class="language-plaintext highlighter-rouge">Canvas</code></h3><p>在<strong>层叠拼图Plus</strong>小游戏内，针对需要大量使用且绘图繁复的静态场景，都是使用离屏 <code class="language-plaintext highlighter-rouge">Canvas</code>进行绘制的，如首页网格背景、关卡列表、排名列表等。在微信内 <code class="language-plaintext highlighter-rouge">wx.createCanvas()</code> 首次调用创建的是显示在屏幕上的画布，之后调用创建的都是离屏画布。初始化时将静态场景绘制完备，需要时直接拷贝离屏<code class="language-plaintext highlighter-rouge">Canvas</code>的图像即可。<code class="language-plaintext highlighter-rouge">Canvas</code> 绘制本身就是不断的更新帧从而达到动画的效果，通过使用离屏 <code class="language-plaintext highlighter-rouge">Canvas</code>，就大大减少了一些静态内容在上屏<code class="language-plaintext highlighter-rouge">Canvas</code>的绘制，从而提升了绘制性能。</p><div class="language-javascript highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">this</span><span class="p">.</span><span class="nx">offScreenCanvas</span> <span class="o">=</span> <span class="nx">wx</span><span class="p">.</span><span class="nx">createCanvas</span><span class="p">()</span>
<span class="k">this</span><span class="p">.</span><span class="nx">offScreenCanvas</span><span class="p">.</span><span class="nx">width</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">width</span> <span class="o">*</span> <span class="nx">ratio</span>
<span class="k">this</span><span class="p">.</span><span class="nx">offScreenCanvas</span><span class="p">.</span><span class="nx">height</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">height</span> <span class="o">*</span> <span class="nx">ratio</span>

<span class="k">this</span><span class="p">.</span><span class="nx">ctx</span><span class="p">.</span><span class="nx">drawImage</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">offScreenCanvas</span><span class="p">,</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">ratio</span><span class="p">,</span> <span class="nx">y</span> <span class="o">*</span> <span class="nx">ratio</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">offScreenCanvas</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">offScreenCanvas</span><span class="p">.</span><span class="nx">height</span><span class="p">)</span>
</pre></table></code></div></div><h3 id="内存优化">内存优化</h3><p>玩家在游戏过程中拖动方块的移动其实就是不断更新多边形图形的坐标信息，然后不断的清空画布再重新绘制，可以想象，这个绘制是非常频繁的，按照普通的做法就需要不断去创建多个新的 <code class="language-plaintext highlighter-rouge">Block</code> 对象。针对游戏中需要频繁更新的对象，我们可以通过使用<code class="language-plaintext highlighter-rouge">对象池</code>的方法进行优化，对象池维护一个装着空闲对象的池子，如果需要对象的时候，不是直接<code class="language-plaintext highlighter-rouge">new</code>，而是从对象池中取出，如果对象池中没有空闲对象，则新建一个空闲对象，<strong>层叠拼图Plus</strong>小游戏内使用的是官方<code class="language-plaintext highlighter-rouge">demo</code>内已经实现的<code class="language-plaintext highlighter-rouge">对象池</code>类，实现如下：</p><div class="language-javascript highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre><td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">__</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">poolDic</span><span class="p">:</span> <span class="nb">Symbol</span><span class="p">(</span><span class="dl">'</span><span class="s1">poolDic</span><span class="dl">'</span><span class="p">)</span>
<span class="p">}</span>

<span class="cm">/**
 * 简易的对象池实现
 * 用于对象的存贮和重复使用
 * 可以有效减少对象创建开销和避免频繁的垃圾回收
 * 提高游戏性能
 */</span>
<span class="k">export</span> <span class="k">default</span> <span class="kd">class</span> <span class="nx">Pool</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">[</span><span class="nx">__</span><span class="p">.</span><span class="nx">poolDic</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="p">}</span>

  <span class="cm">/**
   * 根据对象标识符
   * 获取对应的对象池
   */</span>
  <span class="nx">getPoolBySign</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">[</span><span class="nx">__</span><span class="p">.</span><span class="nx">poolDic</span><span class="p">][</span><span class="nx">name</span><span class="p">]</span> <span class="o">||</span> <span class="p">(</span> <span class="k">this</span><span class="p">[</span><span class="nx">__</span><span class="p">.</span><span class="nx">poolDic</span><span class="p">][</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">)</span>
  <span class="p">}</span>

  <span class="cm">/**
   * 根据传入的对象标识符，查询对象池
   * 对象池为空创建新的类，否则从对象池中取
   */</span>
  <span class="nx">getItemByClass</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">className</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">pool</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">getPoolBySign</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>

    <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">(</span>  <span class="nx">pool</span><span class="p">.</span><span class="nx">length</span>
                  <span class="p">?</span> <span class="nx">pool</span><span class="p">.</span><span class="nx">shift</span><span class="p">()</span>
                  <span class="p">:</span> <span class="k">new</span> <span class="nx">className</span><span class="p">()</span>  <span class="p">)</span>

    <span class="k">return</span> <span class="nx">result</span>
  <span class="p">}</span>

  <span class="cm">/**
   * 将对象回收到对象池
   * 方便后续继续使用
   */</span>
  <span class="nx">recover</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">instance</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">getPoolBySign</span><span class="p">(</span><span class="nx">name</span><span class="p">).</span><span class="nx">push</span><span class="p">(</span><span class="nx">instance</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="垃圾回收">垃圾回收</h3><p>小游戏中，<code class="language-plaintext highlighter-rouge">JavaScript</code> 中的每一个 <code class="language-plaintext highlighter-rouge">Canvas</code> 或 <code class="language-plaintext highlighter-rouge">Image</code> 对象都会有一个客户端层的实际纹理储存，实际纹理储存中存放着 <code class="language-plaintext highlighter-rouge">Canvas</code>、<code class="language-plaintext highlighter-rouge">Image</code> 的真实纹理，通常会占用相当一部分内存。</p><p>每个客户端实际纹理储存的回收时机依赖于 <code class="language-plaintext highlighter-rouge">JavaScript</code> 中的 <code class="language-plaintext highlighter-rouge">Canvas</code>、<code class="language-plaintext highlighter-rouge">Image</code> 对象回收。在 <code class="language-plaintext highlighter-rouge">JavaScript</code> 的 <code class="language-plaintext highlighter-rouge">Canvas</code>、<code class="language-plaintext highlighter-rouge">Image</code> 对象被回收之前，客户端对应的实际纹理储存不会被回收。通过调用 <code class="language-plaintext highlighter-rouge">wx.triggerGC()</code> 方法，可以加快触发 <code class="language-plaintext highlighter-rouge">JavaScriptCore Garbage Collection</code>（垃圾回收），从而触发 <code class="language-plaintext highlighter-rouge">JavaScript</code> 中没有引用的 <code class="language-plaintext highlighter-rouge">Canvas</code>、<code class="language-plaintext highlighter-rouge">Image</code> 回收，释放对应的实际纹理储存。</p><p>但 <code class="language-plaintext highlighter-rouge">GC</code> 具体触发时机还要取决于 <code class="language-plaintext highlighter-rouge">JavaScriptCore</code> 自身机制，并不能保证调用 <code class="language-plaintext highlighter-rouge">wx.triggerGC()</code> 能马上触发回收，<strong>层叠拼图Plus</strong>小游戏在每局游戏开始或结束都会触发一下，及时回收内存垃圾，以保证最良好的游戏体验。</p><h3 id="多线程-worker">多线程 Worker</h3><p>对于游戏来说，每帧 <code class="language-plaintext highlighter-rouge">16ms</code> 是极其宝贵的，如果有一些可以异步处理的任务，可以放置于 <code class="language-plaintext highlighter-rouge">Worker</code> 中运行，待运行结束后，再把结果返回到主线程。<code class="language-plaintext highlighter-rouge">Worker</code> 运行于一个单独的全局上下文与线程中，不能直接调用主线程的方法，<code class="language-plaintext highlighter-rouge">Worker</code> 也不具备渲染的能力。 <code class="language-plaintext highlighter-rouge">Worker</code>与主线程之间的数据传输，双方使用 <code class="language-plaintext highlighter-rouge">Worker.postMessage()</code> 来发送数据，<code class="language-plaintext highlighter-rouge">Worker.onMessage()</code> 来接收数据，传输的数据并不是直接共享，而是被复制的。</p><div class="language-javascript highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="c1">// game.json</span>
<span class="p">{</span>
  <span class="dl">"</span><span class="s2">workers</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">workers</span><span class="dl">"</span>
<span class="p">}</span>

<span class="c1">// 创建worker线程</span>
<span class="kd">let</span> <span class="nx">worker</span> <span class="o">=</span> <span class="nx">worker</span> <span class="o">=</span> <span class="nx">wx</span><span class="p">.</span><span class="nx">createWorker</span><span class="p">(</span><span class="dl">'</span><span class="s1">workers/request/index.js</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// 文件名指定 worker 的入口文件路径，绝对路径</span>

<span class="c1">// 主线程向 Worker 发送消息</span>
<span class="nx">worker</span><span class="p">.</span><span class="nx">postMessage</span><span class="p">({</span>
  <span class="na">msg</span><span class="p">:</span> <span class="dl">'</span><span class="s1">hello worker</span><span class="dl">'</span>
<span class="p">})</span>

<span class="c1">// 主线程监听 Worker 返回消息</span>
<span class="nx">worker</span><span class="p">.</span><span class="nx">onMessage</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span>
<span class="p">})</span>
</pre></table></code></div></div><p><strong><em>需要注意的是：<code class="language-plaintext highlighter-rouge">Worker</code> 最大并发数量限制为 <code class="language-plaintext highlighter-rouge">1</code> 个，创建下一个前请用 <code class="language-plaintext highlighter-rouge">Worker.terminate()</code> 结束当前 <code class="language-plaintext highlighter-rouge">Worker</code></em></strong></p><p>其他 <code class="language-plaintext highlighter-rouge">Worker</code> 相关的内容请参考微信官方文档：<a href="https://developers.weixin.qq.com/minigame/dev/guide/base-ability/worker.html">多线程 Worker</a></p><h2 id="结语">结语</h2><p>短短的一篇文章，定不能将<strong>层叠拼图Plus</strong>小游戏的前前后后讲明白讲透彻，加上文笔有限，有描述不当的地方还望多多海涵。其实最让人心累的还是软著的申请过程，由于各种原因前前后后花了将近三个月的时间，本来也想写一下软著申请相关的内容，最后发现篇幅有点长，无奈作罢，争取后面花点时间整理一下我这边的经验，希望可以帮助到需要的童鞋。</p><p>由于项目结构以及代码还比较混乱，个人觉得，目前暂时还不适合开源。<strong><em>好在，小游戏内的所有核心代码以及游戏实现思想均已呈上</em></strong>，有兴趣的同学如果有相关方面的疑问也可以与我多多交流，大家互相学习，共同进步。</p><p>体验游戏：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-gold-cdn.xitu.io/2019/8/19/16ca8b653f22285f?w=258&amp;h=258&amp;f=jpeg&amp;s=42561" alt="code" /></p><p>江湖不远，我们游戏里见！</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E4%BB%A3%E7%A0%81%E4%BA%BA%E7%94%9F/'>代码人生</a>, <a href='/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/'>小程序</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F/" class="post-tag no-text-decoration" >微信小游戏</a> <a href="/tags/javascript/" class="post-tag no-text-decoration" >JavaScript</a> <a href="/tags/canvas/" class="post-tag no-text-decoration" >Canvas</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=烧脑！JS+Canvas带你体验「偶消奇不消」的智商挑战 - kokohuang's blog&url=https://kokohuang.github.io/posts/weapp-game-stack/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=烧脑！JS+Canvas带你体验「偶消奇不消」的智商挑战 - kokohuang's blog&u=https://kokohuang.github.io/posts/weapp-game-stack/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=烧脑！JS+Canvas带你体验「偶消奇不消」的智商挑战 - kokohuang's blog&url=https://kokohuang.github.io/posts/weapp-game-stack/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>最近更新</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/swift-design-patterns/">Swift设计模式概览</a><li><a href="/posts/swift-leetcode/">LeetCode 刷题笔记</a><li><a href="/posts/swift-leetcode-0026/">LeetCode - 删除有序数组中的重复项</a><li><a href="/posts/git-history/">Git仓库迁移保留提交记录</a><li><a href="/posts/ios-custom-object-copy-archive/">iOS自定义对象及子类及模型套模型的拷贝、归档存储的通用代码</a></ul></div><div id="access-tags"> <span>热门标签</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/swift/">Swift</a> <a class="post-tag" href="/tags/ios/">iOS</a> <a class="post-tag" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a> <a class="post-tag" href="/tags/leetcode/">LeetCode</a> <a class="post-tag" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a> <a class="post-tag" href="/tags/%E7%AE%97%E6%B3%95/">算法</a> <a class="post-tag" href="/tags/git/">Git</a> <a class="post-tag" href="/tags/javascript/">JavaScript</a> <a class="post-tag" href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/">微信小程序</a> <a class="post-tag" href="/tags/%E6%95%B0%E7%BB%84/">数组</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">文章目录</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>推荐阅读</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/weapp-loaction/"><div class="card-body"> <span class="timeago small" > 2020年01月02日 <i class="unloaded">2020-01-02T12:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>「腾讯位置服务」全面拥抱微信小程序，让出行更简单！</h3><div class="text-muted small"><p> 一、引言 1.1「腾讯位置服务」是什么？ 立足生态，连接未来 「腾讯位置服务」平台依托庞大的数据生态，以定位、地图展示、地点搜索、路线规划、导航、室内图、海外图等位置服务能力和LBS大数据能力为基础，面向开发者提供方便、易用、高效的LBS服务产品。当前「腾讯位置服务」数据能力已覆盖10亿人的位置行为数据、日均超过600亿次的定位调用、每日支持1亿次位置检索。 1.2「腾讯...</p></div></div></a></div><div class="card"> <a href="/posts/gitter/"><div class="card-body"> <span class="timeago small" > 2019年01月25日 <i class="unloaded">2019-01-25T12:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Gitter - 高颜值GitHub小程序客户端诞生记</h3><div class="text-muted small"><p> 0. 前言 嗯，可能一进来大部分人都会觉得，为什么还会有人重复造轮子，GitHub第三方客户端都已经烂大街啦。确实，一开始我自己也是这么觉得的，也问过自己是否真的有意义再去做这样一个项目。思考再三，以下原因也决定了我愿意去做一个让自己满意的GitHub第三方客户端。 对于时常关注GitHub Trending列表的笔者来说，迫切需要一个更简单的方式随时随地去跟随Git...</p></div></div></a></div><div class="card"> <a href="/posts/swift-design-patterns-mediator/"><div class="card-body"> <span class="timeago small" > 2020年04月17日 <i class="unloaded">2020-04-17T12:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Swift设计模式之「中介者模式」</h3><div class="text-muted small"><p> 在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/gitter/" class="btn btn-outline-primary" prompt="上一篇"><p>Gitter - 高颜值GitHub小程序客户端诞生记</p></a> <a href="/posts/weapp-loaction/" class="btn btn-outline-primary" prompt="下一篇"><p>「腾讯位置服务」全面拥抱微信小程序，让出行更简单！</p></a></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://github.com/kokohuang">kokohuang</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">保留部分权利.</span></p></div><div class="footer-right"><p class="mb-0"> 本博客由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，使用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 作为主题.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">热门标签</h4><a class="post-tag" href="/tags/swift/">Swift</a> <a class="post-tag" href="/tags/ios/">iOS</a> <a class="post-tag" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a> <a class="post-tag" href="/tags/leetcode/">LeetCode</a> <a class="post-tag" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a> <a class="post-tag" href="/tags/%E7%AE%97%E6%B3%95/">算法</a> <a class="post-tag" href="/tags/git/">Git</a> <a class="post-tag" href="/tags/javascript/">JavaScript</a> <a class="post-tag" href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/">微信小程序</a> <a class="post-tag" href="/tags/%E6%95%B0%E7%BB%84/">数组</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://kokohuang.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
