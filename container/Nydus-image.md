# 下一代镜像：Nydus

## OCI 容器镜像的问题

尽管 OCI Image 的设计蕴含了“完整的操作系统就是一个包”的优秀思想，又利用 Union FS 实现了“分层”机制方便开发以及节约存储的精巧设计，但是随着时间的推移，在大规模集群的应用实践上，OCIv1 镜像格式还是存在着一些问题。

这些问题主要集中在：

- **内容冗余**：不同层之间相同信息在传输和存储时都是冗余内容，在不读取内容的时候无法判断到这些冗余的存在
- **无法并行**：单一层是一个整体，对同一个层既无法并行传输，也不能并行提取
- **无法进行小块数据的校验** 只有完整的层下载完成之后，才能对整个层的数据做完整性校验

上述这些问题用一句话来总结就是 “层是镜像的基本单位”，然而，镜像的数据的实际使用率是很低的。比如 Cern 的一篇论文中就提到：一般镜像只有6%的内容会被实际用到，可见，下一代镜像的一个趋势就是打破层的结构来对这些只读进行更进一步的优化。这就产生了实质性升级镜像数据结构，不再以层为基本单位的需求动力。

## Nydus 镜像

Nydus 镜像加速框架是 Dragonfly 的子项目，它提供了容器镜像按需加载的能力，在生产环境支撑了每日百万级别的加速镜像容器创建，在启动性能，镜像空间优化，端到端数据一致性，内核态支持等方面相比 OCIv1 有巨大优势。

K8s 集群使用的运行时为 Containerd ，而 Containerd 也支持使用插件 Nydus Snapshotter 来识别 Nydus 镜像，同时在使用 Nydus 功能时, Nydus 也支持原生的 OCI 镜像，只是没有按需加载相关功能。

Nydus 主要包含一个新的镜像格式，和一个负责解析容器镜像的 FUSE 用户态文件系统进程。

<div  align="center">
	<img src="../assets/nydus-image.webp" width = "550"  align=center />
</div>

## Nydus 工作流程

<div  align="center">
	<img src="../assets/nydus.png" width = "550"  align=center />
</div>

Nydus 镜像格式并没有对 OCI 镜像格式在架构上进行修改，而主要优化了其中的 Layer 数据层的数据结构。

Nydus 将原本统一存放在 Layer 层的文件数据和元数据 （文件系统的目录结构、文件元数据等） 分开，分别存放在 “Blob Layer” 和 “Bootstrap Layer” 中。并对 Blob Layer 中存放的文件数据进行分块 （Chunk） ，以便于懒加载 （在需要访问某个文件时，只需要拉取对应的 Chunk 即可，不需要拉取整个 Blob Layer） 。

同时，这些分块信息，包括每个 Chunk 在 Blob Layer 的位置信息等也被存放在 Bootstrap Layer 这个元数据层中。这样，容器启动时，仅需拉取 Bootstrap Layer 层，当容器具体访问到某个文件时，再根据 Bootstrap Layer 中的元信息拉取对应 Blob Layer 中的对应的 Chunk 即可。

## Nydus 优势

- 容器镜像按需下载，用户不再需要下载完整镜像就能启动容器。
- 块级别的镜像数据去重，最大限度为用户节省存储资源。
- 镜像只有最终可用的数据，不需要保存和下载过期数据。
- 端到端的数据一致性校验，为用户提供更好的数据保护。
- 兼容 OCI 分发标准和 artifacts 标准，开箱即可用。
- 支持不同的镜像存储后端，镜像数据不只可以存放在镜像仓库，还可以放到 NAS 或 者类似 S3 的对象存储上。
- 与 Dragonfly 的良好集成。


用户部署了 Nydus 镜像服务后，由于使用了按需加载镜像数据的特性，容器的启动时间明显缩短。在官网的测试数据中，Nydus 能够把常见镜像的启动时间，从数分钟缩短到数秒钟。理论上来说，容器镜像越大，Nydus 体现出来的效果越明显。

<div  align="center">
	<img src="../assets/nydus-performance.png" width = "550"  align=center />
</div>

