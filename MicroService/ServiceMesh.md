# Service Mesh

ServiceMesh 又称服务网格。之所以称为服务网格，是因为每台节点同时运行着业务逻辑和代理。这个代理被形象地称为 Sidecar （业务逻辑相当于主驾驶，共享一个代理相当于边车），服务之间通过 Sidecar 发现和调用目标服务，从而在服务之间形成一种网络状依赖关系。然后通过一种独立部署称为 “控制平面”（Control Plane）的组件来集中管理这种依赖关系，以进行路由、流量调拨等操作。

如果我们把节点和业务逻辑从视图剥离，就会出现一种网络状的架构。服务网络由此得名。


<div  align="center">
	<img src="../assets/service-mesh.jpeg" width = "350"  align=center />
</div>

## 为什么要使用 Service Mesh

服务网格并没有给我们带来新功能，它是用于解决其他工具已经解决过的问题，只不过这次是在云原生环境下的实现。

在 Service Mesh 之前，微服务架构所带来的问题都采用框架思维解决，将服务发现、熔断、限流、可观测性等能力以SDK的形式提供给开发人员。

随着业务发展和微服务规模不断增大，框架思维的架构瓶颈逐渐凸显，其一：单一的编程语言无法实现所有的业务需求，针对异构环境的服务治理框架实现往往存在差异，缺少共性问题的统一解决方案，各个编程语言的SDK维护和迭代困难。其二： SDK 和 应用在同一个进程内紧密耦合，这种强绑定关系使他们无法独立快速演进，从而陷入基础支撑技术和业务演进发展相互制约的困境。

Service Mesh 的出现使解决问题的思路从框架思维变成了平台思维，将之前SDK中非常固定的内容仍保留在SDK中，其他内容则剥离至完全独立的 Proxy（Sidecar）中。 Proxy 的热升级技术将平台功能变更对应用完全无感，实现了应用逻辑和服务治理能力解耦，从而最大程度解决了 框架SDK和业务耦合无法独立演进的问题。


上述问题的解决方案是，将服务治理功能从应用本身剥离出来作为单独进程，与主应用程序共同放在一台主机（Host）中，但会将它们部署在各自的进程或容器中。这种方式也被称为 Sidecar（边车）模式。


### Sidecar 模式

使用 sidecar 模式部署服务网格时，无需在节点上运行代理，但是集群中将运行多个相同的 sidecar 副本。在 sidecar 部署方式中，每个应用的容器旁都会部署一个伴生容器（如 Envoy 或 MOSN），这个容器称之为 sidecar 容器。Sidecar 接管进出应用容器的所有流量。在 Kubernetes 的 Pod 中，在原有的应用容器旁边注入一个 Sidecar 容器，两个容器共享存储、网络等资源，可以广义的将这个包含了 sidecar 容器的 Pod 理解为一台主机，两个容器共享主机资源。

因其独特的部署结构，使得 sidecar 模式具有以下优势：

- 将与应用业务逻辑无关的功能抽象到共同基础设施，降低了微服务代码的复杂度。
- 因为不再需要编写相同的第三方组件配置文件和代码，所以能够降低微服务架构中的代码重复度。
- Sidecar 可独立升级，降低应用程序代码和底层平台的耦合度。

