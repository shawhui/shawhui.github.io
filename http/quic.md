# 引入 QUIC

QUIC (Quick UDP Internet Connections) 是一种基于 UDP 封装的安全、可靠传输协议，他的目标是取代 TCP 并自包含 TLS 成为标准的安全传输协议。

下图是 QUIC 在协议栈中的位置，基于 QUIC 承载的 HTTP 协议进一步被标准化为 HTTP3。

<div  align="center">
	<img src="../assets/quic.png" width = "420"  align=center />
</div>

## QUIC 出现的背景

在 QUIC 发布之前，HTTP 中使用 TCP 作为传输数据的底层协议。然而，随着移动互联网的不断发展，人们对实时交互和更多样化的网络场景的需求越来越大。此外，智能手机和便携式设备越来越成为主流，目前有超过 60% 的互联网流量通过无线传输。

然而，传统的TCP这种已经使用了40多年的传输层通信协议，在目前大规模远距离、移动网络差、网络切换频繁的背景下，存在先天的性能瓶颈，无法满足需求主要源于以下三个原因：

### 建立连接时握手延迟大

无论是HTTP1.0/1.1还是HTTPS、HTTP2，都是使用TCP进行传输。 HTTPS 和 HTTP2 也需要使用 TLS 协议进行安全传输。这导致两次握手延迟：
TCP 三次握手导致建立 TCP 连接的延迟。
完整的 TLS 握手至少需要 2 个 RTT 才能建立，而简化的握手需要 1 个 RTT 握手延迟。
对于很多短连接场景，这种握手延迟影响很大，无法消除。

### 队头阻塞

以 HTTP/2 多路复用为例，多个数据请求在同一个 TCP 连接上作为不同的流发送，应用层的所有流都必须按顺序处理。如果一个流的数据丢失，后面的其他流的数据将被阻塞，直到丢失的数据被重传，即使接收端已经收到后续流的数据包，也不会通知应用层。此问题称为 TCP 流的队头阻塞 (HoL)

### TCP 僵化问题

TCP 协议最初设计用于支持端口、选项和功能的添加和修改。然而，由于 TCP 协议的悠久历史以及众所周知的端口和选项，许多中间件（例如防火墙和路由器）已经变得依赖于这些隐式规则。因此，这些中间件可能无法正确支持对协议的任何更改，这可能会导致互操作性问题。

TCP协议在操作系统内核中实现，但由于Windows XP等许多老系统平台仍有大量用户，用户端操作系统版本升级非常困难。此外，TCP 用户对它的功能很满意，并且可能会抵制可能影响其行为的更改。所以，要快速推动TCP协议的更新并不是那么容易的。


## QUIC的改进及优势

QUIC的出现解决了最后一公里的网络传输问题。QUIC 采用 UDP 作为其传输协议，与 TCP 相比具有更低的延迟和更高的吞吐量，并且它还使 QUIC 能够绕过可能干扰 TCP 的网络中间件。 QUIC 包含基于 TLS 1.3 的内置加密协议，可在端点之间提供安全通信，并使第三方更难拦截和操纵互联网流量。从 SMB 等协议中加入一些命令和版本控制，然后混合一组新的协议概念和效率，这就是 QUIC 的用武之地——结合了 UDP 的速度和效率、TLS 的安全性，以及HTTP3，为现代互联网创建可靠和高性能的传输协议。


我们这里列举一下 QUIC 的重要特性，这些特性是 QUIC 得以被广泛应用的关键。

### 连接迁移

当用户的地址发生变化时，如 WIFI 切换到 4G 场景，基于 TCP 的 HTTP 协议无法保持连接的存活。QUIC 基于连接 ID 唯一识别连接。当源地址发生改变时，QUIC 可以实现无缝切换，保证连接存活和数据正常收发。

<div  align="center">
	<img src="../assets/quic-connection.png" width = "580"  align=center />
</div>

### 低连接延时

以一个 HTTPS 的请求为例，即使在最好的 TLS1.3 的 early data 下仍然需要 1RTT 开启数据传输。而对于目前线上常见的 TLS1.2 完全握手的情况，则需要 3RTT 开启数据传输，另外对于 TCP Fastopen 等方案，由于协议僵化的问题，也难以在网络中应用。


<div  align="center">
	<img src="../assets/tcp-handshake.png" width = "580"  align=center />
</div>


QUIC 由于基于 UDP，无需 TCP 连接，在最好情况下，短连接下 QUIC 可以做到 0RTT 开启数据传输。

<div  align="center">
	<img src="../assets/quic-handshake.png" width = "580"  align=center />
</div>

QUIC在握手过程中使用 DH(Diffie-Hellman)算法协商初始密钥，DH 密钥协商需要通行双方各自生成自己的非对称公私钥对。

server 端与客户端的关系是 1vN 的关系，server 端生成一份公私钥对, 让 N 个客户端公用, 能明显减少生成开销。server 端的这份公私钥对就是专门用于握手使用的，客户端一经获取，就可以缓存下来后续建连时继续使用, 这个就是达成0-RTT握手的关键。

### 可插拔拥塞控制

QUIC使用可插拔的拥塞控制，相较于TCP，它能提供更丰富的拥塞控制信息。比如对于每一个包，不管是原始包还是重传包，都带有一个新的序列号(seq)，这使得QUIC能够区分ACK是重传包还是原始包，从而避免了TCP重传模糊的问题。

QUIC支持可插拔的Cubic、BBR、Reno等拥塞控制算法，也可以根据具体场景定制私有算法。 “可插拔”意味着它可以灵活地生效、更改和停止。体现在以下几个方面：

- 不同的拥塞控制算法可以在应用层实现，不需要操作系统或内核的支持，而传统的TCP拥塞控制需要端到端的网络协议栈才能达到控制效果。
- 允许单个应用程序的不同连接支持不同的拥塞控制配置。
- 应用程序无需停机或升级即可更改拥塞控制。我们唯一要做的就是修改配置并在服务器端重新加载它。


### 更快的连接

使用 HTTPS 时，TCP 连接需要“3 次握手”，然后在建立连接之前设置 TLS 协议。QUIC（基于 UDP）不需要 3 次握手，而且它在初始握手过程中交换了安全密钥，这使得建立加密连接的速度提高了一倍。

### 降低对丢包的敏感度

在 TCP 中，如果一个数据包被丢弃，所有后续的数据包都将被阻止，直到丢失的数据包被发送出去。这被称为“队头阻塞”，会显著增加延迟。在弱网环境下，HTTP2的队头阻塞问题在用户体验上极为糟糕。

**改进多路复用以避免 HoL 阻塞**

QUIC 引入了在连接上复用多个流的概念。 QUIC 通过为每个流设计和实现单独的流量控制，解决了影响整个连接的队头阻塞问题。

QUIC 的多路复用类似于 HTTP/2。可以在单个 QUIC 连接上同时发送多个 HTTP 请求（流）。然而，让 QUIC 的多路复用超越 HTTP/2 的是，在单个连接上每个流之间没有顺序依赖。这意味着如果流 2 丢失了一个 UDP 数据包，它只会影响流 2 的处理，不会阻塞流 1 和 3 的数据传输。因此，该解决方案不会导致 Head-of-Line Blocking。

<div  align="center">
	<img src="../assets/quic-head-block.png" width = "480"  align=center />
</div>

此外，作为 QUIC 的一项新功能，HPACK 标头压缩格式的变体 QPACK 旨在减少通过网络传输的冗余数据量，从而有助于缓解 Head-of-Line Blocking。

这样 QUIC 在弱网场景下可以接收到比 TCP 更多的数据。


